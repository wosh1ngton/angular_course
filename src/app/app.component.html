<div class="container">

  <nav [style.backgroundColor]="backgroundColor" *ngIf="isNotLogin" class="navbar navbar-expand-md navbar-light bg-light">
    <div class="container-fluid">
      <a href="#" class="navbar-brand">
        <img src="../assets/AngularJS-Shield.svg" width="50px" height="55px" alt="">
        <strong style="font-size: 15px"> Curso de Angular </strong>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarPrincipal"
        aria-expanded="false" aria-label="Toggle navigation" aria-controls="navbarPrincipal">
        <span class="navbar-toggler-icon">
        </span>
      </button>

      <div class="collapse navbar-collapse flex-row d-flex " id="navbarPrincipal">
        <ul class="navbar-nav lh-base" small>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Home'"
              [class.active]="menuEscolhido == 'Home'">Home</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Diretivas'"
              [class.active]="menuEscolhido == 'Diretivas'">Diretivas</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Componente'"
              [class.active]="menuEscolhido == 'Componente'">Componentes</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Template'"
              [class.active]="menuEscolhido == 'Template'">TDD</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'reactive'"
              [class.active]="menuEscolhido == 'reactive'">RDD</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'services'"
              [class.active]="menuEscolhido == 'services'">Services</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'routers'"
              [class.active]="menuEscolhido == 'routers'">Rotas</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'autenticacao'"
              [class.active]="menuEscolhido == 'autenticacao'">Autenticação</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Outros'"
              [class.active]="menuEscolhido == 'Outros'">Outros</a>
          </li>        
         
        </ul>
        <div class="p-1">
          <span *ngIf="!authService.isLoggedIn()">
            <a routerLink="/login"  > Login </a>
          </span>
          <span   *ngIf="authService.isLoggedIn()">
            Olá {{authService.currentUser.username}}
            <a (click)="authService.logout()" > [ Sair ] </a>
            
          </span>
          <span  *ngIf="authService.isLoggedIn() && authService.currentUser.admin=='true'">
            <a routerLink="/admin"> Adm </a>
          </span>
        </div>
      
      </div>
    </div>
  </nav>
  <router-outlet> </router-outlet>
 
  <div *ngIf="isNotLogin" [ngSwitch]="menuEscolhido">
    
    <div *ngSwitchCase="'Diretivas'">
      <app-submenus [subMenus]="menusDiretivas" (menuAtivado)="updateViewMode($event)"> 
      </app-submenus>    

      <div [ngSwitch]="viewMode">
        <div *ngSwitchCase="'if'" class="m-2">
          <h3> Como adicionar ou remover elementos da página </h3>
          <span class="fs-6 lh-base">
            Para adicionar ou remover um elemento, utilize *NgIf em conjunto com uma expressão ou variável booleana.
            Por padrão, ngIf evita que seja exibido um elemento com um valor nulo associado. Há diversas formas de
            adicionar ou
            remover elementos, no exemplo abaixo, a div aparecerá se a condição do if retornar verdadeiro, caso retorne
            falso, o elemento
            é retirado da tela e também do DOM.
          </span>

          <div class="mt-3 row g-2 bg-light p-2">
            
              <div class="col-auto">
                <label for="totalDeCursos" class="align-middle">Total de Cursos</label>
              </div>
              <div class="col-auto">
                <input type="number" #totalCursos class="form-control form-control-md">
              </div>
              <div class="col-auto">
                <button class="btn btn-primary btn-md" (click)="onKeyUp(totalCursos.value)">Enviar</button>
              </div>
              <div class="col-auto">
                <span class="align-middle">Informe um valor e clique em enviar para testar a diretiva ngIf </span>
              </div>
            
          </div>

          <h5 class="m-2"> 1. Utilizando a diretiva *ngIf </h5>
          <span class="fs-6 lh-base">
            Para testar o exemplo informe um valor para Total de Cursos no formulário logo acima, se o valor for maior
            que 0 haverá cursos e a div com a mensagem "Lista de Cursos" aparecerá, caso seja 0 a div exibida será 
            a que possui a mensagem "Ainda não há cursos".
          </span>
          <pre class="bg-light">
                {{ textoHtml }}
              </pre>

          <div *ngIf="courses.length > 0" class="p-3 bg-light text-primary border border-primary">
            Lista de Cursos
          </div>

          <div *ngIf="courses.length == 0" class="p-3 bg-light text-danger border border-danger">
            Ainda não há cursos
          </div>
          <h5 class="m-2"> 2. Utilizando *ngIf com template variable e ng-template </h5>
          <span class="fs-6 lh-base">
            A seguir, têm-se o mesmo resultado do if anterior, utilizando ng-template e a instrução else,
            repare que a template variable #noCourses e #coursesList foram utilizadas para chamar o ng-template
            correspondente. a template variable é a referência para a div que será exibida conforme resultado
            do if.
          </span>

          <pre class="bg-light">
                {{ textoHtmlIfNGTemplate }}
          </pre>

          <div *ngIf="courses.length > 0; then coursesList else noCourses"> </div>
          <ng-template #coursesList class="border border-primary text-primary">
            <div class="border border-primary text-primary-3 p-3"> Lista de Cursos </div>             
          </ng-template>

          <ng-template #noCourses>
            <div class="border border-danger text-danger p-3"> Ainda não há cursos </div> 
          </ng-template>
          
          <h5 class="m-2">3. Utilizando hidden para adicionar ou remover elementos </h5>

          <span class="lh-base fs-6">
            O atributo hidden é uma alternativa para ocultar e mostrar elementos, pode ser utilizado como uma property
            bind em conjunto com uma expressão booleana, o resultado da expressão define se o elemento aparece ou não,
            a principal diferenção para o ngIf é que, neste caso, ambas as divs aparecem no DOM, ou seja, se inspecionarmos
            o HTML verificaremos que as duas divs estão no código fonte, embora não apareçam na tela.
          </span>         
          <pre class="bg-light">
            {{textoHtmlHidden}}
          </pre>
          <div [hidden]="courses.length == 0" class="text-primary border border-primary p-3">
            Lista de cursos
          </div>
          <div [hidden]="courses.length > 0" class="text-danger border border-danger p-3">
            Ainda não há cursos
          </div>

        </div>

        <div *ngSwitchCase="'switch'"> 
          <h3 class="p-2"> Como utilizar a diretiva ngSwitchCase</h3>
          <div>
          <span class="lh-base fs-6">
            O ngSwitchCase directive é recomendável para quando queremos comparar uma property ou um field 
            contra múltiplos valores, um exemplo prático de uso seria a ativação de menus quando clicados. 
            Conforme exemplificado abaixo, neste cenário, tem-se uma lista de opções, quando a opção for clicada
            o evento (click) atribui um valor para a property testeSwitch, esse valor atribuído é utilizado 
            para verificar se a classe 'active' utilizada para destacar a opção clicada será ou não habilitada,
            para que ela seja habilitada é necessário que a expressão "testeSwitch == 'valor'" seja verdadeira. Em sendo 
            verdadeira além da ativação da classe active, a div correspondente será exibida, conforme instrução
            ngSwitchCase.
          </span>
          
          
        </div>
          <pre class="bg-light">
            {{ textoSwitchCase }}
          </pre>
       
          <ul class="nav nav-tabs">
            <li class="nav-item"> 
              <a href="#" class="nav-link" [class.active]="testeSwitch == 'mapa'" (click)="testeSwitch = 'mapa'">Mapa</a>  
            </li>
            <li class="nav-item"> 
              <a href="#" class="nav-link" [class.active]="testeSwitch == 'lista'" (click)="testeSwitch = 'lista'">Lista</a> 
            </li>
            <li class="nav-item"> 
              <a href="#" class="nav-link" [class.active]="testeSwitch == 'outros'" (click)="testeSwitch = 'outros'">Outros</a> 
            </li>
          </ul>

          <div [ngSwitch]="testeSwitch">
            <div *ngSwitchCase="'mapa'" class="p-2"> Conteúdo de Mapa </div>
            <div *ngSwitchCase="'lista'" class="p-2"> Conteúdo de Lista </div>
            <div *ngSwitchCase="'outros'" class="p-2"> Conteúdo de Outros </div>
          </div>
       
        </div>

        <div *ngSwitchCase="'for'">
          <h3 class="p-2">Utilizando o NgFor</h3>
          <span class="fs-6 lh-base">
            Utilizado para renderizar uma lista de objetos o NgFor tem também valores exportáveis,
            são valores que podem ser extraídos com o uso de palavras reservadas, estes valores são:
            first: boolean; index: number; last: boolean; even: boolean; odd: boolean; count int, o significado é
            auto-explicativo. No exemplo abaixo o usuário informa a quantidade de cursos que quer exibir,
            valor entre 1 e 10 e o ngFor faz a exibição do html correspondente. Também é possível incluir os
            índices e marcar se deseja apenas as ocorrências pares ou ímpares.
          </span>
          <div class="row g-2 p-3 bg-light mt-2">
            <div class="col-auto">
              <label class="align-middle" for="totalDeCursos"> Informe a quantidade de cursos<br /> a serem exibidos</label>
            </div>
            <div class="col-auto">
              <input type="number" class="form-control" id="totalDeCursos" #total>
            </div>
            <div class="col-auto">
              <input type="button" class="btn btn-primary" value="Ver Cursos" (click)="onClickSendTotal(total.value)">
            </div>
            <div class="col-auto form-check form-switch m-3">              
              <input type="checkbox" class="form-check-input" id="flexSwitchIndice"  [(ngModel)]="mySwitch" > 
              <label for="flexSwitchIndice" class="form-check-label"> Mostrar índices? </label>
            </div>
            <div class="col-auto form-check form-switch m-3">              
              <input type="checkbox" class="form-check-input" id="flexSwitchIndice" [(ngModel)]="switchPar"> 
              <label for="flexSwitchIndice" class="form-check-label"> Mostrar apenas pares? </label>
            </div>
            <div class="col-auto form-check form-switch m-3">              
              <input type="checkbox" class="form-check-input" id="flexSwitchIndice" [(ngModel)]="switchImpar"> 
              <label for="flexSwitchIndice" class="form-check-label"> Mostrar apenas ímpares? </label>
            </div>
          </div>
          <ul class="list-group list-group-flush">            
            <li class="list-group-item" *ngFor="let curso of cursos; let i = index; let isEven = even; let isOdd = odd; trackBy: trackby">

              <div *ngIf="switchImpar == true; then impares; else null;"> </div>
              <div *ngIf="switchPar == true; then pares; else null;"> </div>
              <div *ngIf="switchPar == false && switchImpar == false; then todos; else null;"> </div>

              <ng-template #impares>
                  <span *ngIf="isEven"> <span [hidden]="mySwitch == false"> {{ i }} - </span> {{ curso.nome }}  </span>
              </ng-template>

              <ng-template #pares>
                <span *ngIf="isOdd"> <span [hidden]="mySwitch == false"> {{ i }} - </span> {{ curso.nome }} </span>
              </ng-template>

              <ng-template #todos>
                <span> <span [hidden]="mySwitch == false"> {{ i }} - </span> {{ curso.nome }}  </span>                 
              </ng-template>              
            </li>
          </ul>


          <pre class="bg-light">
            {{ textoFor }}
          </pre>
          <h4> Uso do trackBy </h4>
          <span class="m-2 fs-6 lh-base">
            A diretiva NgFor possui a variável trackBy que recebe uma função, a função implementa a forma como
            as mudanças nos elementos serão rastreados pelo angular, caso ela não seja implementada o padrão do Angular é utilizar
            a referência do objeto, ou seja, será sempre um valor novo quando a página for atualizada, caso deseje
            que o Angular substitua os itens da lista somente quando forem de fato adicionados novos itens,
            implemente o método trackByFn, este método recebe dois parâmetros: index e item. O uso do trackBy é especialmente
            útil quando temos um grande volume de dados, usando o trackBy diminuímos o uso de recursos, auxiliando
            no desempenho da aplicação.
          </span>

          <pre class="bg-light">
            {{textoTrackBy}}
          </pre>
        </div>
        <div *ngSwitchCase="'ngclasse'" class="m-2">
          <h3> Utilizando o ngClass </h3>
          <span class="fs-6 lh-base">
            Suponha a necessidade da criação de um componente para favoritar um determinado item,
            esse componente deve ficar preenchido quando clicado pela primeira vez (favoritado) e deve
            se esvaziar quando desfavoritado, para implementar essa ação você pode utilizar um duplo 
            class binding, onde sempre que o item for clicado a classe oposta a que está 
            ativada é habilitada, assim:
            
            <pre class="bg-light">
              {{ textoClassBinding }}
            </pre>
          </span>
          <span class="mb-4"> Clique na estrela para visualizar o funcionamento do componente </span>
          <app-favorite [favorito]="post.isFavorite" (change)="onFavoriteChanged($event)"> </app-favorite>
          <br />
          <span class="fs-6">
            Uma abordagem alternativa seria utilizar o ngClass, passando um objeto chave valor onde o nome da
            classe é a chave e a propriedade é o valor, assim:
          </span>
          <pre class="bg-light">
            {{ textoNgClass }}
          </pre>
          <span> O que também pode ser feito com o uso de uma expressão no class binding, passando a 
            expressão como um objeto, bastante similar ao ngClass, assim:
          </span>
          <pre class="bg-light">
            {{textoExpressaoClassBinding}}
          </pre>
    
        </div>
        <div *ngSwitchCase="'ngestilo'">
          <h3 class="m-2"> Utilizando o NgStyle </h3>
          <span class="fs-6 lh-base">
            Similar ao ngClass, o ngStyle permite que seja passado um objeto com as chaves funcionando
            como o nome dos atributos css e os valores podem ser expressões que retornam o valor para 
            o atributo.
          </span>
          <button
            [style.backgrounColor]="canSave ? 'blue': 'red'"
            [style.color]="canSave ? 'blue' : 'black'">             
            Salvar 
          </button>
          
    
        </div>
        <div *ngSwitchCase="'outros'" class="m-2">
          <h4> Leading Asterisk </h4>
          <span class="fs-6 lh-base">
            O asterisco que precede as diretivas *ngIf, *ngFor e outras é utilizado para sinalizar a
            substituição do conteúdo interno do elemento que o contém por um ng-template, na prática ele
            facilita a construção dos blocos ngIf encapsulando a criação dos blocos, sem o seu uso a criação
            de um ngIf teria que prever o if e o else, veja no código abaixo como seria:
          </span>
          <pre class="bg-light">
            {{ textNgIfSemAsterisco }}
          </pre>
          </div>

     
      </div>
      
    </div>
    
    <div *ngSwitchCase="'Componente'">
      <app-submenus [subMenus]="menusComponentes" (menuAtivado)="updateViewMode($event)"></app-submenus>

      <div [ngSwitch]="viewMode">

        <div *ngSwitchCase="'overview'" class="m-2">
          <h3> Visão Geral dos Componentes </h3>
          <span class="fs-6">
            As aplicações Angular são baseadas em componentes, os componentes são os principais blocos de 
            construção do Angular. Cada componente possui:           
          </span>
          <ul class="list-group list-group-flush fs-6">
            <li class="list-group-item"> <small> Um template HTML com a marcação e conteúdo da página </small></li>
            <li class="list-group-item"> <small>  classe TypeScript que define o comportamento do componente </small></li>
            <li class="list-group-item"> <small> Um seletor CSS que define como o componente será invocado </small></li>              
          </ul>
          <span>
              Para criar um componente é requisito ter instalado também o Angular CLI e também ter 
              criado um workspace do Angular com os arquivos iniciais de uma aplicação Angular, para 
              criar digite ng new project-name, onde project-name é o nome de sua aplicação angular.
          </span>

          <h4 class="mt-2">Criando um componente</h4>
          <span>
            A melhor forma de criar um componente é pelo uso do Angular CLI, mas também pode ser feito 
            manualmente, para criar através do  Agular CLI, navegue até a pasta do seu projeto Angular, digite            
             <code class="bg-light">ng generate component component-name </code>, conde component-name 
            é o nome do seu componente. Por padrão, este componente cria o seguinte:
          </span>
          <ul class="list-group list-group-numbered fs-6">
            <li class="list-group-item">Um diretório com o mesmo nome do componente</li>
            <li class="list-group-item">O arquivo do componente component-name.component.ts</li>
            <li class="list-group-item">Um template html, component-name.component.html</li>
            <li class="list-group-item">Um arquivo CSS, component-name.component.css</li>
            <li class="list-group-item">Um arquivo de especificação de testes component-name.component.spec.ts</li>
          </ul>
        </div>

        <div *ngSwitchCase="'viewencapsualtion'" class="m-2">
          
          <h3> View Encapsulation </h3>
          <span>
            No angular, o estilo de um componente pode ser encapsulado para limitar-se ao componente, assim, 
            não afeta o restante da aplicação, dentro do @Component decorator é disponibilizada a opção 
            encapsulation, que pode ser utilizada para controlar como o encapsulamento é aplicado. 
            Existem os seguintes modos:
          </span>
          <table class="table table-striped table-bordered">
           <thead>
            <tr>
              <th>Modo</th>
              <th>Detalhe</th>
            </tr>
          </thead>
        <tbody>
        
            <tr>
              <td> ViewEncapsulation.ShadowDom</td>
              <td> O Angular utilizará o Shadow DOM API built-in do navegador para aplicar os estilos de forma isolada ao componente, contudo, 
                nem todos os navegadores possuem suporte para tal.</td>
            </tr>
            <tr>
              <td> ViewEncapsulation.Emulated</td>
              <td> O Angular modifica os seletores CSS aplicados ao componente, dessa forma ele emula o Shadow DOM. 
                Exemplo: quando definimos no css do nosso componente um  h1  color: red; os elementos h1 
                definidos no html do componente receberão um atributo do tipo ngcontent, e o angular criará 
                uma marcação css diferenciada para todos os h1 que tiverem esse atributo, assim:
                <pre>
                  {{textoEncapsulation}}
                 </pre> 
              </td>
            </tr>
            <tr>
              <td> ViewEncapsulation.None</td>
              <td> O Shadow DOM não é aplicado, assim, os estilos são válidos globalmente.</td>
            </tr>
          </tbody>
          </table>
        </div>

          <div *ngSwitchCase="'sharingdata'" class="m-2">
            <h3> Compartilhamento de Dados </h3>
            <div>
             <h5> Input e Outputs properties  </h5>
              <span>
              Quando trabalhamos com componentes, eventualmente necessitamos utilizar suas propriedades e 
              seus métodos para passar o estado do componente e reagir a eventos disparados, para isso, 
              utilizamos Input e Output properties, a isso dá-se o nome de "public API". Sem as anotações 
              de Input e Output não é possível utilizar property binding e event binding no componente.
            </span> <br />

            <span>
              Os decorators @Input() e @Output() permitem o compartilhamento de dados entre child e parent 
              directives e components, o @Input() permite que o componente pai atualize dados no componente 
              filho, já o @Output() permite que o elemento filho envie dados para o elemento pai.
            </span>
            
            <h4 class="mt-3"> Enviando dados para um elemento filho </h4>
              

              O @Input() decorator em um elemento filho ou diretiva significa que a propriedade pode 
              receber seu valor de um componente pai, ele passa a ser uma entrada de dados.
            <br />
            <code>
              @Input => Parent => Child.
            </code>
            <br>
            Para utilizar o @Input é preciso configurar parent e child elements. o @Input é declarado
            onde se pretende receber o valor <br />
            <code>
            @Input() item = '';
            </code>
            <br />
            item pode ser de qualquer tipo, inclusive um objeto, o valor de item vem do componente pai. 
            No template do componente filho, tem-se:
            <br />
            <code>              
              {{textoInputP}}
            </code>
            <br>
            <span>
              No componente pai, fazemos o property binding propriamente dito, neste caso estamos 
              trabalhando no app-component como sendo o componente pai, pois ele engloba o componente 
              app-item-detail.
            </span>
            <br>
            <code>{{textoInputCP}}</code>
            <br>
            <span>
              Agora basta passar o valor para a input property, esse valor, no nosso exemplo é o currentItem,
              considerando que o child element recebe o valor, quem passa é o parent element, no nosso exemplo, o valor
              virá do AppComponent.
            </span>
            <br>
            <code> {{textoInputValor}}</code>

            
            <h4 class="mt-3"> Enviando dados para o componente pai</h4>
            <span>
              o @Output decorator em um componente filho ou diretiva permite o fluxo de dados do filho para o pai. 
              o componente filho utiliza o @Output decorator para subir um evento para notificar o componente pai 
              da mudança, para subir o evento, um @Output precisa ter o tipo EventEmitter, que é uma classe do 
              @angular/core que utilizamos para emitir eventos customizados. 
              O exemplo a seguir mostra como configurar um @Output() em um componente filho que envia dados de um 
              HTML para uma array no componente pai. Para usar o @Output() é preciso configurar parent e child.
            </span>

            <h5> Configurando o componente filho </h5>
            <span> O componente emissor do evento precisa de uma property com a tag de @Output 
              e precisa de um método que lance o evento. Suponha então que na child class tenha-se o 
              seguinte cenário:
            </span>
            <pre class="bg-light"> {{ textoOutputP }} </pre>

            <h5> Configurando o template do elemento filho</h5>
            <span>
              Ao clicar no botão o método addNewItem() do componente é acionado, ele possui como parâmetro 
              o valor da template variable #newItem, que nada mais é que o valor que o usuário irá 
              informar no campo de texto
            </span>
            <pre class="bg-light">
              {{ textoOutputEF }}
            </pre>
              <h5>Configurando o componente pai</h5>
              <span>
                Neste exemplo, utilizamos o AppComponent, o qual terá uma lista de itens e um método 
                para adicionar mais itens. o método addItem() irá receber o argumento, no exemplo, 
                uma string.
              </span>
              <pre class="bg-light">
                {{textoCodigoAddItem}}
              </pre>

              <h5>Configurando o template do elemento pai</h5>

              <span>
                No template, (app.component.html), linkamos o método do elemento pai (addItem()), com o 
                evento, marcado como @Output no elemento filho (newItemEvent). Essa chamada é feita na 
                tag do elemento filho, assim:

                <pre class="bg-light">
                  {{textoCodigoChamada}}
                </pre>

                
              </span>
              <span>
                O event binding, (newItemEvent)='addItem($event)', liga o evento do elemento filho ao 
                método do elemento pai. o objeto $event contém os dados que o usuário informa no . Para ver 
                o @Output() funcionando, adicione o seguinte no parent's template:
              </span>

              <pre class="bg-light">
                {{textoExibicao}}
              </pre>
            </div>
          </div>
        </div>
    </div>
    
    <div *ngSwitchCase="'Template'">
      <app-submenus [subMenus]="menusTemplates" (menuAtivado)="updateViewMode($event)"></app-submenus>
      <div [ngSwitch]="viewMode">
        <div *ngSwitchCase="'validacao'" class="m-2">
      <h5 class="mt-3"> Template Driven </h5>
      <span>
        O Angular possui uma classe chamada FormControl, para cada campo existente no formulário essa 
        classe é associada a um objeto que consegue verificar o status e valor do campo. Os estados do campo podem ser:
        <ul class="list-group small">
          <li class="list-group-item">touched: campo foi clicado </li>
          <li class="list-group-item">untouched </li>
          <li class="list-group-item">dirty (value foi alterado) </li>
          <li class="list-group-item">pristine (value não foi alterado) </li>
          <li class="list-group-item">valid </li>
          <li class="list-group-item">erros </li>
        </ul> 
      </span>   
      <span class="mt-3">
        Na mesma linha, existe a classe FormGroup, representa um grupo de controles em um form, todo form tem
        pelo menos um objeto FormGroup.
        Há duas formas de criar controles para seu formulário, uma é por meio de diretivas de forma automática
        (template driven) a outra maneira é criar explicitamente através de código (reactive forms) neste caso
        há um maior controle sobre a lógica de validação. Reactive form é mais recomendável para modelos
        complexos.
        Quando utilizamos a diretiva ngModel, estamos dizendo ao Angular para criar
        um FormControl para aquele input field, sempre que o fazemos devemos também preencher o atributo name 
        do input field.
        <br />
        O campo Nome, codificado abaixo, é um FormControl, para ver o seu funcionamento basta exportar
        o ngModel para uma template variable local, no código de exemplo estamos exportando o valor de ngModel 
        para a template variable #firstName. Tecle f12 e veja o resultado do 
        console.log do javascript, ele deverá mostrar o objeto ngModel.
        Observe o atributo required no input field, ele sinaliza que o campo é de preenchimento obrigatório,
        na mesma linha o atributo minlenght estabelece um número mínimo de caracteres, note que são os mesmos
        atributos que o HTML5 utiliza para validação. o Angular utiliza diretivas para casar esses atributos com 
        as funções de validação do framework. Sempre que o valor de um form é alterado o Angular executa 
        a validação e gera ou uma lista de erros com o resultado INVALID para o objeto, ou nulo, que seria
        o equivalente a VALID.
        a div a seguir contém várias divs aninhadas, elas têm a função de aparecer quando a condição do ngIf 
        não for satisfeita, ou seja, quando a template variable firstName passada para o FormControl 
        for inválida.
        Caso queira customizar a formatação do erro de validação, utilize as classes do angular que apontam para 
        o erro, por exemplo, configure a borda vermelha para as classes .form-control.ng-invalid.ng-touched, dessa 
        forma os elementos dentro de um form-control tocados e inválidos terão a borda vermelha.
      </span>
        <pre class="bg-light">{{ textoNgModel }}</pre>
      
      <app-contact-form> </app-contact-form>
      </div>
    
      <div *ngSwitchCase="'ngForm'">
        <span>
          Por padrão a diretiva ngForm é acrescentada "under the hood" em todos os formulários html 
          quando importamos o módulo FormsModule do Angular,
          para termos uma referência da diretiva ngForm podemos utilizar uma template variable, setando 
          dentro da tag form #f="ngForm", observe que é a mesma lógica para exportar o valor de ngModel 
          para uma template variable em um input field.                    
        </span>
        <h4>ngSubmit</h4>
        <span class="mt-3">
          o NgForm tem uma output property chamada ngSubmit, sendo uma output property ela é do tipo
          EventEmitter e portanto é uma forma de enviar dados a um parent item através do evento ngSubmit.
          Para ver o resultado clique no botão enviar e veja o objeto que está sendo enviado através do console
          das ferramentas do desenvolvedor. <br />
          Repare o elemento button, utilizamos um atributte binding, onde o atributo disabled desabilita
          o botão enquando o formulário estiver no estado inválido, o atributo recebe o valor da template 
          variable #f a qual é atribuída o valor do ngForm.
        </span>
        <pre class="bg-light">{{textoNgForm}}</pre>
        <h4>NgModelGroup</h4>
        <span>
          Outra maneira de separar conceitos é utilizando a diretiva ngModelGroup, quando a diretiva é adicionada 
          a uma div os input fields dentro dela passam a ser considerados atributos de um objeto. Imagine que os
          primeiros campos de um formulário são todos referentes a contato, você pode envolvê-los em uma div 
          e nomear o ngModelGroup como contato, criando uma template variable com o valor #contato e passando 
          para a template variabel o valor de ngModelGroup, conforme demonstrado no código abaixo:
        </span>
        <pre class="bg-light">
          {{textoNgModelGroup}}
        </pre>
        <span> ao clicar no checkbox é possível ver o valor da variável ngModel a ele associada, 
          conseguimos isso através da instrução <code> f.value | json </code>
          <br/>
          sendo f o valor do ngForm em formato json, por isso todo os valores são exibidos, incluindo o input field 
          nome e comentário.
        </span>

  
        <app-contact-form></app-contact-form>
        
      </div>
      <div *ngSwitchCase="'ngValue'">
        <span>
          Ao trabalhar com formulários, eventualmente queremos enviar não apenas um id através de um 
          select box, mas sim o objeto como um todo, imagine a seguinte situação, você tem um tipo de contato 
          e gostaria que ao selecionar o o tipo de contato o objeto fosse integralmente enviado, tanto o id como
          o nome do tipo de contato.
          <br />
          o objeto seria algo como:
          <pre class="bg-light">
            {{textoObjetoContact}}
          </pre>

          o select box seria assim:

          <pre class="bg-light">
            {{textoSelectBox}}
          </pre>
          <app-selectbo>

          </app-selectbo>

        </span>
        <span>
          Com essa abordagem somente o property bind de value é acionado, e somente o id do método de contato
          é enviado, mas isso não é o que queremos, queremos o objeto todo, para enviar o objeto todo basta
          substituir [value] por [ngValue] e contacts.id por contacts. Assim:                
          
        </span>
        <pre class="bg-light">
          {{textoNgValue}}
        </pre>

        <app-select-box2>

        </app-select-box2>
        
      </div>
    </div>
    

  </div>
  <div *ngSwitchCase="'reactive'">
    <app-submenus [subMenus]="menusReactive" (menuAtivado)="updateViewMode($event)">

    </app-submenus>
    <div [ngSwitch]="viewMode">
      <div *ngSwitchCase="'visaogeral'">
        <h5 class="mt-3">Funcionamento do Reactive Driven</h5>
        <span>
          Reactive form transfere mais responsabilidades para o desenvolvedor, o controle dos formulários passa
          a ser feito diretamente no componente e as associações destes formControls com os input fields 
          no template são feitas através de diretivas próprias tais como:
          <strong> formControlName </strong> o qual é representado como um atributo, usado
          para linkar ao input field do FormControl.
          O <strong>  formGroupName</strong> usado para linkar os FormGroups do componente com os grupos 
          do template. Por último o <strong> [formGroup]</strong>, representado como uma property bind, 
          a qual vincula o formulário do template com o form object criado no componente. <br />
          
          O formulário de login, abaixo representado, fora criado usando 
          a abordagem reactive driven do angular. Para tanto, criou-se um objeto FormGroup, composto de outros dois 
          objetos FormControl, um para o username e outro para o password. No template, esses objetos são invocados 
          utilizando o atributte binding no form <code> [formGroup]="form" </code> e atribuição de valor 
          nos inputs utilizando o atributo formControlName para username e password.      
        </span>
        <h5 class="mt-3">Validação de Dados no Reactive Driven </h5>
        <span class="mt-3">
          No reactive form os atributos do HTML não são utilizados para validação, para criar validações é preciso 
          fazê-lo dentro do formControl correspondente, um formControl possui alguns parâmetros, todos eles 
          são opcionais, o primeiro trata do estado inicial do form, o segundo é um validator que é do tipo 
          ValidatorFn[] | ValidatorFn[], ou seja é uma função do tipo Validator (classe built-in do Angular) 
          ou uma array de funções Validator. No Código 1 é possível ver o uso de vários validators e como 
          implementá-los.
        </span>
        <h5 class="mt-3"> Simplificando a chamada do formControl </h5>
        <span>
          as propriedades do form control podem ser obtidas por meio do método get, assim: form.get('name').valid, para simplificar
          essa chamada convém criar uma property no componente, conforme código 2:
        </span>
        <app-coder [parametros]="t"> </app-coder>
        <app-coder [parametros]="codigoSimplificado"> </app-coder>        
        <app-signup-form></app-signup-form>
        
        
      </div>
      <div *ngSwitchCase="'validacaoCustomizada'">
        <h5 class="mt-3">Criando uma validação customizada no Reactive Driven</h5>
        <span>
          Para criar uma validação customizada é preciso criar uma ValidatorFn e passá-la ao seu formControl
          o validatorFn é uma interface e portanto possui um padrão para sua implementação. Para implementar 
          é preciso um AbstractControl que retorne um ValidatorError ou nulo.
        </span>
        <app-coder [parametros]="pp" > </app-coder>
        <h5 class="mt-3">Implementando no template </h5>
        <span>
          O uso no template é exatamente igual ao que seria feito com um validador comum, no componente o 
          validator é chamado através de uma chamada ao método estático criado no username.validator, assim:
        </span>
        <app-coder [parametros]="validadorSignUp"> </app-coder>
       
      </div>
      <div *ngSwitchCase="'validacaoAssincrona'">
        <h5 class="mt-3">Validação Assíncrona </h5>
        <span>
          Para realizar uma validação assíncrona é preciso implementar a interface AsyncValidatorFn,
          essa interface possui a seguinte assinatura:
        </span>
        <app-coder [parametros]="asyncValidatorFn"> </app-coder>
        <span>
          Repare que a interface recebe um AbstractControl como parâmetro e retorna uma promisse de validationErrors ou nulo OU
          um Observable de ValidationErrors ou null. Isso significa que quando a operação for concluída 
          receberemos como retorno uma promise de ValidationErrors ou um Observable de ValidationErrors ou nulo <br />

          também convém compreender como funciona o conceito de operação assíncrona, conceito explicitado 
          neste link (criar link). No nosso exemplo criaremos um método para testar se um valor informado 
          no formulário de login é único. 
          <br />
          O código abaixo retorna um resolve ou um reject, o reject em caso de erro, o resolve se a operação 
          for bem sucedida. O resolve retorna um ValidatorError ou nulo, shouldBeUnique é um ValidatorError, 
          lembrando que o que define um validatorErrorFn é um AbstractControl como parâmetro e o retorno 
          de um outro ValidatorError ou nulo.
        </span>
        <app-coder [parametros]="exemploAsyncValidatorFn"></app-coder>
        <span class="mt-3"> Repare que há um delay entre a digitação do valor no campo e a resposta do 
          navegador, para deixar claro que o sistema está trabalhando, convém uma mensagem ao usuário de 
        loading, isso pode ser obtido através da propriedade <strong>pending </strong> do FormControl, essa 
      propriedade fica ativa enquanto a operação assíncrona está funcionando, para adicioná-la basta 
     utilizar um NgIf para que enquanto pending for verdadeiro apareça uma mensagem do tipo 
    "Checando por valor único" ou uma imagem de loading </span>
      </div>
      <div *ngSwitchCase="'validacaoForm'">
        <span class="mt-3">
          Caso deseje checar um erro que pode ser originado de qualquer parte do formulário, ou seja,
          pode vir de mais de um campo, é possível fazer uma validação no formulário. Suponha que deseje 
          testar se o usuário e senha do componente de login retornaram o valor correto, o form validation 
          pode ser utilizado para isso. 
          <br />
          Abaixo, uma função que gera um erro para o formulário ao tentar logar.

        </span>
        <app-coder [parametros]="erroUsuarioSenha"></app-coder>
        <span class="mt-3">
          Para mostrar o erro, utilizamos o ngIf dentro de uma Div se o form tiver quaisquer erros,
          eles serão mostrados. Caso precise testar vários erros, convém criar uma div, dentro da div principal 
          para cada erro adicional.

        </span>
        
        <app-coder [parametros]="erroUsuarioSenhaTemplate"></app-coder>
        <h5 class="mt-3">Aninhamento de grupos no Reactive Driven</h5>
        <span>
          Para aninhar grupos na abordagem reactive driven, utilize a diretiva FormGroupName dentro do template 
          dessa forma, o Angular entenderá que há formGroups aninhados no componente, por exemplo. Se você possui 
          no seu componente um código assim:
        </span>
        <app-coder [parametros]="codigoFormGroupAninhado"></app-coder>
        <span class="mt-3">
          deverá implementar o seu template assim:
        </span>
        <app-coder [parametros]="codigoFormGroupTemplate"> </app-coder>
        <span>

        </span>

        
      </div>
      <div *ngSwitchCase="'FormArray'">
        <h5 class="mt-3">Trabalhando com um FormArray </h5>
        <span>
          O FormArray é mais uma classe que assina a interface AbstractControl, mesma família do FormGroup. Para 
          utilizar um FormArray você pode criar um objeto do tipo FormGroup e colocar um FormArray dentro dele,
          como no código de exemplo abaixo:
        </span>

        <br/>
        <app-coder [parametros]="codigoFormArray"></app-coder>
        <p class="mt-3">
          Imagine que você precise criar uma lista de itens de supermercado, a medida que o usuário preencha
          um campo de texto eles devem ser armazenados em uma lista e exibidos na tela, outra funcionalidade 
          importante é que os itens sejam removidos quando clicados. Para fazer isso, 
          basta criar um método de adição de itens, cada item será parte do FormArray, a implementação 
          deste método seria assim:
        </p>
        <app-coder [parametros]="codigoAddTopicoFormArray"></app-coder>
        <p class="mt-3">
          Perceba que a função addTopic recebe como parâmetro um input text field do html, perceba também que uma property 
          de nome topics foi criada para facilitar a referência ao FormArray, sempre que o addTopic for chamado 
          será inserido no FormArray um novo FormControl com o valor informado no FrontEnd, o código 
          do FrontEnd fica assim:
        </p>

        <app-coder [parametros]="codigoFrontEndFormArray"></app-coder>

        <p class="mt-3">
          Teste o Componente abaixo: digite um texto qualquer e tecler enter para chamar o método addTopic, para 
          remover, basta clicar sobre o item da lista que o método removeTopic será chamado.
        </p>
        <app-gerador-objetos></app-gerador-objetos>
      </div>
      <div *ngSwitchCase="'FormBuilder'">
        Antes de falarmos do FormBuilder é importante compreender o que é um Builder dentro do paradigma
        de programação orientado a objetos, um builder é um padrão de criação de objetos, geralmente utilizado 
        em estruturas mais complexas onde um objeto é fruto de uma composição de outros objetos.
        Veja um exemplo da instanciação de um FormGroup padrão (código 1) e em seguida o mesmo resultado 
        utilizando o FormBuilder.
        <app-coder [parametros]="codigoFormBuilder"></app-coder>

        <p class="mt-3">
          Veja que o padrão builder separa a representação do objeto da sua lógica de construção,
          ele precisa de um construtor para criar o builder, esse builder possui métodos parar criar objetos da família 
          de formulários. Veja também que o código que o FormBuilder gera é menor do que a construção 
          do FormGroup.
        </p>
      </div>
    </div>

    
   
    
  </div>

  <div *ngSwitchCase="'services'">
    <app-submenus [subMenus]="menuServices" (menuAtivado)="updateViewMode($event)"> </app-submenus>
    <div [ngSwitch]="viewMode">
      <div *ngSwitchCase="'servicos'">
        <h5 class="mt-3">Separação de Conceitos </h5>
        <p class="mt-3">
          Paradigma em que se baseia o conceito de serviços, estatui que uma classe deve ser responsável
          por apenas um tipo de coisa, uma classe que faz muitas coisas é difícil de manter e testar. 
          Por exemplo, apresentação da lógica de visão e recuperação de dados não devem estar na mesma classe,
          isso aumenta acoplamento e reduz coesão pois as rotinas de recuperação de dados, possivelmente serão repetidas
          em várias classes. Para solucionar essa questão, precisamos separar os conceitos de lógica de apresentação 
          e tratamento de dados, para isso vamos criar um serviço de acesso a dados para o componente. Ou seja,
          o serviço será a camada intermediária entre o componente e o backend.
        </p>
        <h5 class="mt-3">
          Exemplo de separação de conceitos
        </h5>
        <p class="mt-3">
          Veja no código abaixo que a classe PostService se encarrega de acessar e manipular os dados,
          a maneira como ela faz isso está encapsulada na classe de serviço, esses detalhes não devem 
          ser de responsabilidade do componente, o qual deve se preocupar tão somente com a apresentação.
          Neste modelo o componente utiliza injeção de dependência para criar uma instância dos serviços que 
          precisa em seu construtor, como os métodos do HttpClient retornam Observables, para poder 
          ter acesso aos dados na camada de lógica de apresentação os métodos da classe subscrevem o retorno 
          dos services methods e manipulam os dados (map, reduce) conforme conveniência.
        </p>
        <app-coder [parametros]="postService"></app-coder>
        <app-coder [parametros]="postComponent"></app-coder>
      </div>
      <div *ngSwitchCase="'get'">
       
        <h5 class="mt-3">Método get do HttpClient</h5>
          Para simular o backend das aplicações será utilizado o serviço jsonplaceholder, encontrado no endereço 
          jsonplaceholder.typicode.com, este site provê uma série de endpoints com dados para testes.
          Para buscar dados via chamadas remotas você pode utilizar o HttpModule, é um módulo que contém a classe 
          HttpClient, essa classe possui o método get, o qual faz requisições http,
          essa classe é injetada como um serviço e pode ser usada no padrão de injeção de dependência, ou seja,
          por meio de inserção de uma variável tipada no construtor do componente onde deverá ser utilizada.
          <br />
          A chamada do método get pode ser feita conforme código abaixo:
          <app-coder [parametros]="codigoHttpClientGet"></app-coder>
          <span class="mt-3">
            Observe que há uma chamada encadeada na chamada do método, após o get o método subscribe() é chamado,
            isso se deve a necessidade que o método get tem de retornar um Observable, um Observable representa uma 
            sequência de valores ou eventos que ocorrem ao longo do tempo, é desenhada para lidar com fluxos de 
            dados assíncronos e reativos, permitindo que você subscreva para receber atualizações a partir dos 
            fluxos e execute ações quando as atualizações ocorrerem.
            <br />
            Um Observable precisa de um response, o response é passado do método get para o subscribe, o subscribe 
            pode receber os dados e manipulá-los. Veja no exemplo que os dados recebidos do get são atribuídos
            a variável this.posts.
            Em outras palavras, o método subscribe()  define como obter ou gerar valores ou mensagens para serem
            publicadas. 
          </span>
          <app-post></app-post>

          <h5 class="mt-3">Método post do HttpClient</h5>

      </div>
      <div *ngSwitchCase="'post'">
        <p class="mt-3">
          O método post do HTTPClient possui 15 overloads e portanto várias implementações,
          usualmente leva 3 parâmetros, a url, o body e as options http (opcionais). Como todo método httpclient 
          ele retorna um Observable de alguma coisa, pode ser um ArrayBuffer, um blob, uma string um
          evento, etc..
        </p>
        <app-coder [parametros]="codigoHttpClientPost"></app-coder>
        <p class="mt-3">
          O createPost recebe um input text field como parâmetro, faz uma chamada http post, esse método 
          passa a url onde se deseja postar e como segundo argumento passa o valor postado no input. 
          por último subscreve as alterações para ser notificado a medida que elas ocorrerem, a subscrição 
          adiciona o valor postado no server a lista de posts, usa a função splice para adicionar no 
          início da lista e não no final, como seria se fosse utilizado o push. <br />
          Teste o código inserindo um dado qualquer.
        </p>
        <app-post></app-post>
      </div>

      <div *ngSwitchCase="'patch'">
        <p class="mt-3">
          O http patch atualiza apenas os campos que foram alterados, de maneira que ele não envia o 
          objeto inteiro para o server, como faz o put. Abaixo um exemplo:
        </p>

        <app-coder [parametros]="codigoHttpClientPatch"> </app-coder>
      </div>
      <div *ngSwitchCase="'delete'">
        <p class="mt-3">
          O http delete cria um observable que quando subscrito exclui um registro do servidor. 
          não possui um body, apenas uma url e opções http. Sua implementação ficaria assim:
        </p>
        <app-coder [parametros]="codigoHttpClientDelete"></app-coder>
        <p class="mt-3">
          Observe que a implementação do método é bem simples, basta passar a url indicando o 
          item que deseja excluir, na subscrição do método você passa o que deseja fazer com o objeto 
          manipulado, no exemplo, foi excluído do template o elemento correspondente.
        </p>
      </div>
      <div *ngSwitchCase="'dataservice'">
        <h5 class="mt-3">Serviço de acesso a dados</h5>
        <p class="mt-3">
          Suponha que deseje criar um serviço de acesso a dados, uma chamada para um método de recuperação 
          de dados, outro que busque por id específico, outro que delete e outro que atualize, repare que
          são operações comuns que se repetem em vários componentes, ou seja, podemos criar métodos genéricos 
          para tratar essa questão, veja no código abaixo um exemplo do que seria uma classe de serviços.
        </p>
        <app-coder [parametros]="codigoDataService"></app-coder>
      </div>
    </div>
   
  </div>
  
  <div *ngSwitchCase="'routers'">
    <app-submenus [subMenus]="menusRouters" (menuAtivado)="updateViewMode($event)"> </app-submenus>
    
    <div [ngSwitch]="viewMode">
        <div *ngSwitchCase="'geral'"> 
          <h5 class="mt-3">Visão Geral</h5>
          <p class="mt-3">
            Um Router é um serviço que provê navegação entre views e manipulação de URLs
          </p>
          <h5 class="mt-3">3 passos para configurar a navegação </h5>
          <p class="mt-3">
            1º Configurar as rotas - é o mapeamento de um caminho para um componente;
            2º Adicionar um router outlet, é onde é mostrado o componente correspondente quando uma dada rota 
            se torna ativa;
            3º Adicionar links.
          </p>
          <h5 class="mt-3">Configurando uma rota</h5>
          <p class="mt-3">
            1. Para configurar uma rota são necessários os seguintes passos: importar o AppRoutingModule para o seu AppModule,
            adicioná-lo ao seu imports array. 
            <br />
            2. Defina suas rotas no seu array de rotas. Cada rota neste array é um objeto JS que contém duas 
            propriedades. A primeira propriedade, path, define a URL para a rota. A segunda propriedade,
            component, define o componente que o Angular deve utilizar para o caminho. Veja o exemplo abaixo:
          </p>
          <app-coder [parametros]="codigoRotas"></app-coder>
          <p class="mt-3">
            Dentro da seção de imports do AppModule, informe <code>RouterModule.forRoot(routes)</code> indicando 
            ao módulo de rotas, as rotas disponíveis da sua aplicação.
          </p>
          <p class="mt-3">
            3. Agora adicione suas rotas na sua aplicação, primeiro adicione links para os componentes, atribua 
            a uma âncora o que você quer adicionar como rota para o routerLink attribute. Configure o valor do 
            atributo ao componente para mostrar quando um usuário clica em cada link.<br />
      
          </p>
          <app-coder [parametros]="codigoRouterLink"></app-coder>
          <p class="mt-3">
            Em seguida, atualize o template do componente para incluir o router-outlet. Este elemento informa 
            ao angular para atualizar a view da aplicação com o componente da rota selecionada. o router-outlet é 
            uma tag, você deve colocá-la onde quer que os componentes apareçam, veja o exemplo abaixo em funcionamento.
          </p>
          <router-outlet></router-outlet>
          <app-submenus [subMenus]="menusFollowers"> </app-submenus>
          
          
        </div>
        
        <div *ngSwitchCase="'ordem'"> 
            <h5 class="mt-3">Ordem das rotas</h5>
            <p class="mt-3">
              A ordem das rotas é importante o Router utiliza a estratégia first-match, logo,
              rotas mais específicas devem ser colocadas acima de rotas menos específicas. 
              Lista de rotas com caminhos estáticos devem vir primeiro, a rota com wildcard deve 
              vir por último, pois ela casa com qualquer URL
            </p>
            <h5 class="mt-3">Pegando informação de rotas</h5>
            <p class="mt-3">
              Comumente é preciso passar informações de um componente para outro. Por exemplo, considere 
              uma aplicação que mostre uma lista de compras, cada item da lista tem um id único. Para editar um item 
              o usuário clica no botão de edição, o qual abre o componente de editar item de compras, você precisa 
              que o componente carregue os dados daquele item clicado, para isso um router pode ser usado para 
              passar a informação, podemos utilizar ActivatedRoute interface.              

            </p>
            <p class="mt-3">Para obter informações de uma rota, importamos o 
              ActivatedRoute e o ParamMap para o componente onde queremos utilizar., em seguida injetamos 
              no construtor a instância do ActivatedRoute, sem seguida atualizamos o método ngOnInit() para
              acessar o ActivatedRoute e rastrear o parâmetro desejado.
            </p>
            <h5 class="mt-3">ParamMap</h5>
            <p class="mt-3">
              ParamMap é uma interface localizada no módulo router do Angular, é um mapeamento que provê acesso 
              aos parâmetros requeridos e opcionals específicos para uma rota. Ele possui os seguintes membros:
              property keys:string[] -> somente para leitura, guarda o nome dos parâmetros no mapa. <br />
              método <code>  has(name: string):boolean </code>-> Diz se o mapa contém um dado parâmetro <br />
              método <code>  get(name: string) : string | null </code>-> retorna um valor para o parâmetro dado <br/>
              método <code> getlAll(name: string): string[]</code> -> retorna um array contendo um ou mais valores ou um array vazio.
              <br />
              Veja no exemplo abaixo:
            </p>
            <app-coder [parametros]="codigoAcessoParamRoute"></app-coder>

            <p class="mt-3">Repare que o param é um observable que subscreve o resultado para poder 
              fazer a manipulação de dados, o uso do Observable é para manter os dados do componente, para 
              não destruí-lo e recriá-lo em seguida, é utilizado em contextos onde o usuário não irá chamar 
              outro componente, irá apenas informar novos parâmetros.
            </p>
            <h5 class="mt-3">Rotas com múltiplos parâmetros</h5>
            <p class="mt-3">
              Simplesmente adicione o parâmetro adicional na rota no app.module, adicione também no template corresopndente 
              na property routerLink, conforme exemplo abaixo:
            </p>

            <app-coder [parametros]="codigoMultipleRoutes"></app-coder>
        </div>
        <div *ngSwitchCase="'querystring'">
          <h5 class="mt-3">Criando parâmetros opcionais</h5>
          <p class="mt-3">
            Para criar parâmetros opcionais utilizamos o queryParamMap
          </p>
          <ul class="list-group">
            <li class="list-group-item" *ngFor="let archive of archives">
                <a [routerLink]="['archive', archive.year, archive.month]"> {{archive.year}}/{{archive.month}}</a>
            </li>
          </ul>
          
          <p class="mt-3">
            Clique em um link para ativar a rota com dois parâmetros, conforme é possível visualizar na 
            barra de endereços. Ao clicar no link o router-outlet é ativado e exibido o componente associado 
            ao router-link que foi clicado. lembrando que essa associação é definida no app.module.ts, associação 
            path -> component, onde definimos as rotas da nossa aplicação.
          </p>
        
        </div>
    </div>
</div>
<div *ngSwitchCase="'autenticacao'">
  <app-submenus [subMenus]="menusAutenticacao" (menuAtivado)="updateViewMode($event)">    
  </app-submenus>

   
  <div [ngSwitch]="viewMode">
    <div *ngSwitchCase="'visaogeral'">
      <h5 class="mt-3">
        Arquitetura proposta
      </h5>

      <p class="mt-3">
        Abaixo uma abstração da arquitetura utilizada neste exemplo:
      </p>

      <img src="../assets/login.component.ts.png" width="1272px" />


      <p class="mt-3">
        O esquema de autenticação proposto utiliza um json-server para simular o backend,
        a implementação da regra de login será feita no json-server. a base de dados com as informações 
        de usuário, senha e perfil será armazenada em um arquivo json.
        O primeiro passo é instalar o json-server através do comando:
      </p>
      <code>npm install json-server --save-dev </code>
      <p class="mt-3">
        Também se faz necessário instalar o jwt-token pois será utilizado para autenticar o 
        usuário no cliente, de maneira simples o usuário entra com usuário e senha o server 
        verifica se os dados informados constam na base json e retorna para o cliente um token,
        o token é salvo no navegador e passa a ser utilizado como meio para verificar se o 
        usuário está ou não autenticado. Para instalar o jwt utilize o comando abaixo:
      </p>
      <code>npm install jsonwebtoken --save</code>

      <p class="mt-3">
        aproveite para instalar o nodemon para que o json-server fique sempre no estado watch,
        atualizando automaticamente.
        <code>npm install nodemon --save-dev </code>
        Finalizadas estas instalações crie uma entrada em scripts no package.json para simplificar 
        o start do seu servidor json. 
        
      </p>
      <code> 
        "start-auth": "nodemon server/server.js"
      </code> 
      <h5 class="mt-3">Criando a base de dados </h5>
      <p class="mt-3">
        Convém inicialmente criar uma estrutura de diretórios para armazenar o servidor json,
        como será utilizado apenas para testes locais podemos criar dentro da pasta do projeto,
        ficaria assim: 
       
      </p>
      <pre>
        /server
          server.js
        /data
          db.json
      </pre>
      <p class="mt-3">
        Abaixo o nosso db.json:
      </p>
     <app-coder [parametros]="codigoDbJson">
     </app-coder>
     <p class="mt-3">
      Criado o banco de dados precisamos construir as telas de login, 
      e implementar os detalhes no server. Os detalhes disso estão explicitados nas abas 
      Cliente e Servidor do menu acima.
     </p>
    </div>
    <div *ngSwitchCase="'cliente'">
      <h5 class="mt-3">Componente de Login</h5>
      <p class="mt-3">
        O template de login tem um campo para usuário e outro para senha mais um botão para submeter
        os dados informados.
      </p>
      <app-coder [parametros]="codigoTemplateLogin">
      </app-coder>
     <p class="mt-3">O TypeScript do login fica assim:</p>
     <app-coder [parametros]="codigoTypeLogin"></app-coder>
      <p class="mt-3">
        é uma classe que contém uma propriedade do tipo boolean chamada invalidLogin, essa propriedade 
        armazena se a tentativa de login foi ou não bem sucedida, no construtor da classe temos injetado o 
        authservice, que irá ser utilizado na chamada do método de login. Além deste serviço, o componente
        também se utiliza do router service e do activatedRouteService, são usados para fazer o correto
        redirecionamento quando da tentativa de login do usuário.
        Repare também que o método signIn captura eventuais erros da aplicação e seta a propriedade invalidLogin
        como verdadeira quando algum erro é capturado.
      </p>
      <h5 class="mt-3">Serviço de Login</h5>
      <p class="mt-3">
        O código de serviço de login fica assim:
      </p>
      <app-coder [parametros]="codigoAuthService"></app-coder>

      <p class="mt-3">
        esse serviço é responsável por chamar a API que faz a verificação de usuário e senha, além de outras
        funcionalidades como o logout, verifica se o usuário está logado e também qual é o usuário logado.
        O mais relevante para o nosso exemplo é o método login, que recebe as credenciais e utilizando do
        método post do serviço httpClient do Angular faz uma chamada ao servidor (Json-Server), passa também
        um cabeçalho informado que o content-type é do tipo json. A partir da resposta ele mapeia o response
        e verifica se há uma resposta e um token, retornando verdadeiro criasse um token no cliente com os 
        mesmos dados do token criados no servidor, exceto o secret, pois somente o server possui o secret.
        Caso haja algum erro, o erro é lançado na pilha de execução.
      </p>
    </div>
    <div *ngSwitchCase="'servidor'">
      <p class="mt-3">
        Neste exemplo utilizamos o json-server para simular um servidor, mas provavelmente em uma aplicação real
        o uso seria em uma plataforma asp.net ou Java. abaixo o código:        
      </p>
        <app-coder [parametros]="codigoServerJson"> </app-coder>
      <p class="mt-3"> 
        O uso do json-server não está no escopo deste tutorial, o importante aqui é compreender que o servidor
        encapsula a responsabilidade pela regra de negócio de criação do token e pela autenticação.
        A função isAuthenticated recebe o usuário e senha e verifica na nossa base de dados json se o par de chave 
        valor estão na base, o server.post do endpoint /auth/login é o entry point do server devido a chamado do nosso
       serviço de autenticação, que chama exatamente esse endpoint, passa um request que contém um body,
       esse argumento é transmitido ao método isAuthenticated, caso o retorno seja falso um status 401 é retornado 
       juntamente com a mensagem de 'email e /ou senha incorretos.', mas caso seja verdadeiro um token é criado a partir 
       do usuário, senha, perfil e um retorno 200 é enviado.

      </p>
    </div>
    <div *ngSwitchCase="'autorizacao'">
      <h5 class="mt-3">Autorização vs Autenticação</h5>
        <p class="mt-3"> 
          Agora que cuidamos da autenticação, partiremos para a autorização, com o que temos até agora não como impedir,
          por exemplo, que alguém acesse diretamente a página localhost:4200/admin, ou seja, de nada adianta autenticarmos alguém 
          se não pudermos avaliar se essa identidade possui autorização para acessar determinadas páginas, é o que faremos 
          agora. Para utilizarmos a autorização, podemos lançar mão do serviço authservice, como no código abaixo:
        </p>
        <app-coder [parametros]="codigoAuthServiceCliente"> </app-coder>

        <p class="mt-3">
          Essa classe utiliza o serviço de autorização para redirecionar qualquer usuário que não seja administrador para
          a página no-access, para isso, ela implementa a interface CanActivate, que possui um método de mesmo nome, basicamente 
          este método retorna um booleano que decide se determinada rota será ou não ativada, no caso, a rota não será ativada se o retorno for false.
          Um detalhe final é que é preciso dizer, na constate que guarda as rotas da aplicação, a condição de ativação para as rotas,
          informando o authguard como sendo a condição, assim:
        </p>
        <app-coder [parametros]="codigoRotaGuardCondicao"></app-coder>
        
      </div>
  </div>
</div>

<div *ngSwitchCase="'Outros'">
  <app-submenus [subMenus]="outrosmenus" (menuAtivado)="updateViewMode($event)">    
  </app-submenus>
   <div [ngSwitch]="viewMode">
      <div *ngSwitchCase="'ajax'">
        <h4 class="mt-3"> Compreendendo Operações Assíncronas </h4>
        <span>
          Operação assíncrona é um processo que não bloqueia o fluxo principal de execução do programa 
          enquanto aguarda o resultado. Em vez disso, a operação é executada em segundo plano e o resultado 
          é retornado quando estiver disponível. Isso permite que o programa continue a executar outras 
          tarefas enquanto aguarda o resultado da operação, aumentando a eficiência e evitando o 
          travamento do programa.

          Exemplos comuns de operações assíncronas incluem requisições de rede, leitura de arquivos ou 
          operações de banco de dados. Em aplicações web, por exemplo, uma operação assíncrona pode ser 
          usada para carregar dados da API sem interromper a interação do usuário com a página.
          <br />
          O setTimeOut do js também é uma função assíncrona, uma vez que estabelece um tempo para 
          execução e retorno do callback lançado, nesse intervalo, os demais processos rodam em paralelo
          <br />
          Em Javascript, para trabalhar com operações assíncronas utilizamos Observables ou Promises. 
        </span>
        <h4 class="mt-3">O que é uma Promise</h4>
        <span class="mt-3">
          Uma promise é a representação de um valor que pode estar disponível agora, no futuro, ou nunca.
          <strong> é uma maneira de tratar operações assíncronas de forma mais simples e organizada.</strong>
          Uma promise pode ter três estados: pendente (pending), resolvida (resolved) ou rejeitada (rejected).
          Quando a operação assíncrona é iniciada, a Promise é criada com o estado pendente. Quando a operação 
          assíncrona é concluída com sucesso, a Promise é resolvida com o valor resultante. Se a operação falhar,
          a Promise é rejeitada com um erro. <br/>
          As Promises podem ser usadas para lidar com a resposta de uma operação assíncrona, permitindo que você
          escreva código de forma mais clara e organizada. Em vez de lidar com callbacks aninhados, você pode 
          usar métodos como 'then' e 'catch' para manipular a resposta da Promise de forma linear.

        
        </span>
      </div>
      <div *ngSwitchCase="'observables'">
          <h5 class="mt-3">
            Definindo um Observable
          </h5>
          <span class="mt-3">
            Um Observable é um contrato composto de algumas funcionalidades, ele deve definir um 
            callback para manipular três tipos de notificações:
            <table class="table table-stripped">
              <thead>
                <tr>
                  <th> Tipo </th>
                  <th> Detalhes </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>next</td>
                  <td>Parâmetro obrigatório, um handler para cada valor entregue. Chamado nenhuma ou mais vezes
                    depois que a execução se inicia.
                  </td>
                  </tr>
                  <tr>
                    <td>error</td>
                  <td>Opcional. Um handler para uma notificação de erro. Um erro para a execução da instância do 
                    Observable
                  </td>
                </tr>
                <tr>
                  <td>complete</td>
                  <td> Opcional: Um handler para notificar a execução completa. Valores atrasados podem 
                    continuar a serem entregues ao next handler depois que a execução é completa.
                  </td>
                </tr>
                
              </tbody>
            </table>
            <h5 class="mt-3">
              Subscrevendo
            </h5>
            <p class="mt-3">
              Uma instância de um Observable somente publica valores quando é subscrito. A subscrição é feita 
              através do método subscribe() da instância, passando um observer object para receber as 
              notificações.
              Alguns métodos do RxJS podem ser usados para criar observables, são eles:               
              
            </p>
            <table class="table table-stripped table-bordered">
              <thead>
                <tr>
                  <th>Método RxJS</th>
                  <th>Detalhes</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>of(...items)</td>
                  <td>Retorna uma instância de Observable que entrega os valores fornecidos como argumentos 
                    de forma síncrona
                  </td>
                </tr>
                <tr>
                  <td>from(iterable)</td>
                  <td>Converte seus argumentos para uma instância de Observable. Usualmente utilizado para 
                    converter uma array em um Observable.
                  </td>
                </tr>
              </tbody>
            </table>
            <p class="mt-3">
              Uma função next() pode receber uma string message, event objects, valores numéricos,
              ou estruturas, dependendo do contexto, em geral, os dados publicados por um observable 
              são referenciados como um stream. Qualquer tipo de valor pode ser representado
              com um observable, e os valores são publicados como um stream.
            </p>
       
          </span>
          <h5 class="mt-3">
            Chamando um subscribe
          </h5>
          <p class="mt-3"> Uma maneira de chamar um subscribe é passando um objeto com 3 
            valores nomeados, sendo que os dois último são opcionais, um next, um error e um complete.
            Veja no exemplo abaixo:
          </p>
          <app-coder [parametros]="chamadaSubscribe"></app-coder>
      </div>
      <div *ngSwitchCase="'promise'">
        <p class="mt-3">
          Uma promise é uma promessa de que algo irá ou não irá ocorrer, utilizada na programação 
          assíncrona para respresentar um valor futuro, se difencia do Observable pelo fato de que 
          seu valor é tido por antecipação (Eager Load), enquanto que o Observable é lazy load,
          é preciso subscrever o resultado para obtê-lo. 
          Há muitos operators que só existem nos Observables, não sendo possível utilizá-los com 
          promises, por isso é preferível utilizar os Observables.
        </p>

      </div>
      <div *ngSwitchCase="'lifecycle'">
        <h5 class="mt-3">Conceitos Gerais</h5>
        <p class="mt-3">
          Uma instância de componente tem um ciclo de vida, que inicia quando o Angular cria a 
          instância do componente e renderiza o componente junto com seus childs items. O ciclo de vida 
          continua com a detecção de alterações, a medida que o Angular verifica por alterações nos dados 
          do componente, em ambos, componente e template. O ciclo de vida finaliza quando o Angular 
          destrói a instância do componente e remove o template do DOM. As diretivas tem um ciclo 
          de vida similar, a medida que o Angular cria, atualiza e destrói instâncias no curso da execução.
          A aplicação pode utilizar métodos para manipular o ciclo de vida dos componentes e seus eventos.
        </p>
        <p class="mt-3">
          Um exemplo de um life cycle event seria: Quando o Angular (criar ou renderizar, ou criar e renderizar 
          seus filhos, destruir um componente) faça algo definido. Um destes eventos é o ngOnInit() o qual 
          é criado automaticamente pelo CLI, observe que os componentes padrões levam a interface OnInit(),
          a criação do componente por padrão implementa a interface OnInit() a qual possui a função 
          ngOnInit(): void. Este método será invocado quando o componente for inicializado, ou seja, está 
          associado ao life cycle hook de inicialização do componente.
        </p>

        <h5 class="mt-3">Os hook methods podem ser descritos conforme tabela abaixo </h5>
        <table class="table table-stripped table-bordered">
          <thead>
            <tr>
              <th>Hook Method</th>
              <th>Propósito</th>
              <th>Timing</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ngOnChanges()</td>
              <td>Acionado quando o Angular seta ou reseta data-bound input properties. O método recebe 
                um objeto SimpleChanges dos valores atuais e anteriores de uma property. (Observação:
                Isso acontece frequentemente, logo, qualquer operação aqui impacta significativamente a performance)
              </td>
              <td>
                Chamado antes do ngOnInit() (se o componente tiver bound-inputs) e sempre que um ou mais data-bound 
                input properties sejam alteradas. (Observação: Se o seu componente não possui inputs ou uso do componente
                sem acionamento dos inputs, o framework não invocará o ngOnChanges().
              </td>
            </tr>
            <tr>
              <td>ngOnInit()</td>
              <td> Inicializa a diretiva ou componente depois do primeiro display dos data-bound properties 
                e atribuições das diretivas ou properties dos componentes.
              </td>
              <td>Chamado uma vez, depois do primeiro ngOnChanges(). é chamado inclusive quando o ngOnChanges() não é,
                caso onde não há template-bound inputs. </td>
            </tr>
            <tr>
              <td>ngDoCheck()</td>
              <td>Detecta e atua sob mudanças que o Angular não pode ou não vai detectar por si só.</td>
              <td>Chamado imediatamente depois do ngOnChanges() em cada change detection, e imediamente depois 
                do ngOnInit() durante a execução inicial do componente.
              </td>
            </tr>
            <tr>
              <td>ngAfterContentInit()</td>
              <td> Atual quando o Angular projeta conteúdo externo dentro dos component views, ou dentro da view 
                em que a diretiva está.
              </td>
              <td>Chamado uma única vez, depois do primeiro ngDoCheck()</td>
            </tr>
            <tr>
              <td>ngAfterContentChecked()</td>
              <td> Atua quando o Angular checa o conteúdo projetado dentro da diretiva ou componente.</td>
              <td>Chamado depois do ngAfterContentInit() e para cada ngDoCheck()</td>
            </tr>
            <tr>
              <td>ngAfterViewInit()	</td>
              <td> Atua depois que o Angular inicializa os component views e chidls views, ou as views 
                que contém a diretiva
              </td>
              <td>Chamado uma vez, depois do ngAfterContentChecked()</td>
            </tr>
            <tr>
              <td>ngAfterViewChecked()</td>
              <td>Atua depois do Angular checar as comoponent views e child views, ou as views que contém as diretivas</td>
              <td>Chamado depois do ngAfterViewInit() e em cada ngAfterContentChecked()</td>
            </tr>
            <tr>
              <td>ngOnDestroy()	</td>
              <td>Limpa tudo antes do Angular destruir a diretiva ou o componente. Unsubscribe Observables e 
                event handlers associados para evitar memory leaks.
              </td>
              <td>Chamado imediamente antes do Angular destruir a diretiva ou componente</td>
            </tr>
          </tbody>
        </table>

        <h5 class="mt-3">Uso do ngOnInit()</h5>
        <p class="mt-3">
          Um exemplo clássico do uso de ngOnInit() é para fazer uma chamada remota de valores a serem 
          exibidos na página, é comum o uso de chamadas https em sistemas de informação. Fazer essa chamada 
          no construtor da aplicação não é aconselhável pois a criação do componente pelo construtor 
          deve ser segura, consumir poucos recursos e ser simples. O método ngOnInit() pode ser utilizado 
          para isso. Não é recomendável que construtores sejam complexos, eles devem se ater a iniciar variáveis 
          locais para valores simples.
        </p>
      </div>
     
      <div *ngSwitchCase="'erros'">
        <h5> Princípios gerais de exceções</h5>
        <p class="mt-3">
          As exceções são propagadas quando erros ou eventos inesperados ocorrem durante a execução de um
          programa. Quando uma exceção é lançada, o fluxo regular do programa é interrompido, um erro é lançado
          na pilha de chamadas, um catch poderá capturar o erro e tratá-lo, caso não exista um catch o error handler
          padrão da linguagem irá ser acionado.
          O bloco catch é utilizado para capturar/tratar o erro lançado, recuperando do erro ou finalizando 
          o programa de uma maneira organizada, manipulando o erro e dando feedback ao usuário.
          Para compreender o funcionamento do tratamento de exceções, é também importante compreender a pilha
          de chamadas (callstack) de uma exceção. Quando uma exceção é lançada uma estrutura de dados armazena
          a ordem em que os objetos e funções foram chamados.
        </p>
        <h5 class="mt-3">Tipos de Erros</h5>
        <p class="mt-3">
          Há pelo menos dois tipos de erros, os experados e os inesperados. sobre os erros inesperados 
          podemos ainda subdividi-los em três tipos: <br />
       
           Servidor está offline; <br/>
           Rede está off; (Server está on, mas o cliente não consegue alcançar, erro no endereço informado, por exemplo) <br/>
           Exceções não tratadas. (Pode ser por conta de um bug) <br />
        
        </p>
        <p class="mt-3"> Há pelos menos dois tipos gerais de erros esperados: <br />
        Not Found errors (404); <br />
        Bad Request errors (400) <br />
        </p>
        <h5 class="mt-3">Exemplos práticos</h5>
        <p class="mt-3">
          Um observable pode ser utilizado para retornar do servidor os erros de validação de um determinado 
          formulário, esses erros podem ser subscritos e manipulados na property error do subscribe, veja o exemplo 
          abaixo:
        </p>
        <app-coder [parametros]="subscribeComErros"></app-coder>
        <p class="mt-3">
          Observe que a segunda property do observable passado ao subscribe leva um parâmetro do tipo 
          Response, esse parâmetro guarda uma array de erros e várias propriedades como o status do erro,
          podendo ser um erro esperado, como o erro 400, para erros inesperados utilizamos o else.
          Está comentado no código o this.form.setErrors(e), esse código passaria para um objeto form 
          os erros retornados do servidor.
        </p>
        <h5 class="mt-3"> Separando as responsabilidades </h5>
        <p class="mt-3">
          O tratamento de erros deveria ser separado do componente, poderia estar na camada de serviços.
          Para separar os conceitos vamos criar classes para o tratamento dos erros esperados,
          NotFound e BadInput, ambas extendendo AppError. Assim, passamos a tratar os erros da nossa aplicação.
          Na camada de serviços, utilizamos o método pipe para empilhar o mapeamento do response e capturarmos 
          o erro, veja no código abaixo:                     
          
        </p>
        <app-coder [parametros]="codigoPipeCatchError"></app-coder>
        <p class="mt-3">
          No exemplo, foi transferido pro serviço a responsabilidade de lidar com o erro na camada http.
          ele verifica o status do erro e lança o erro para quem chamou o serviço. Na sequência o componente 
          verifica o tipo de erro da aplicação pelo tipo da instância do erro. Veja o código 3:
          
        </p>
        <app-coder [parametros]="codigoErroPostComponent"></app-coder>
        <p class="mt-3">
          o método é subscrito e em caso de erro ele verifica o tipo e exibe uma mensagem para o usuário.
          O tipo do erro é uma implementação que não cabe ao componente e por isso foi delegado a camada 
          de serviço essa verificação. Aqui no componente ele apenas verifica qual a classe do erro para que 
          exiba a mensagem adequada.

        </p>
        <h5 class="mt-3">Criando um ErrorHandler global</h5>
        <p class="mt-3">
          Imagine que você tenha um erro comum a vários componentes, um erro inesperado por exemplo. É um erro que 
          pode ser reutilizado e portanto não precisa repetir a mensagem em todos os componentes. Para 
          criar um manipulador global de um erro, utilize a classe nativa do Angular, ErrorHandler, extenda a classe 
          e implemente o erro. Veja o exemplo no código 4.
        </p>
        <app-coder [parametros]="codigoAppErrorHandler"></app-coder>
        <p class="mt-3">Agora você precisa dizer ao Angular que toda vez que o ErrorHandler for 
          chamado, ou seja, sempre que um erro acontecer, o Angular deve chamar o seu ErrorHandler 
          e não o dele. Para isso é preciso ir no app.module.ts e dizer para substituir o provider 
          ErrorHandler pelo AppErrorHandler, assim:


        </p>
        <app-coder [parametros]="codigoProviderErrorHandler"></app-coder>
        <p class="mt-3">
          Agora sempre que um erro inesperado ocorrer, utilize a instrução throw para lançar para o 
          ErrorHandler. Caso o tipo de erro possível seja apenas um erro inesperado, sequer é preciso 
          chamar o callback de error do subscribe, pois o ErrorHandler é chamado automaticamente.
          Em casos em que há na pilha de erros do callback possíveis erros esperados, é preciso utilizar 
          o callback para poder tratar os erros esperados, como no código abaixo, em que o método delete 
          precisa da chamada do callback de error e o método ngOnInit não, pois só trata de erros 
          inesperados.
        </p>
        <app-coder [parametros]="codigoThrowErrorHandler"></app-coder>
      </div>
      <div *ngSwitchCase="'deploy'">
        <h5 class="mt-3">
          Implantando a sua aplicação
        </h5>
        <p class="mt-3">
          A implantação de uma aplicação precisa levar em conta que ambiente de desenvolvimento e produção,
          usualmente, possui alguma diferenças e portanto, você não vai querer copiar exatamente o que você
          tem no ambiente de desenvolvimento para o ambiente de testes. a pasta node_modules, por exemplo,
          é muito grande e não precisa ser copiada por inteiro, podemos, ao invés disso, utilizar o package.json
          para baixar os pacotes necessários no servidor de produção.
          Outra questão que chama atenção são os arquivos bundles, que são amontoados de arquivos js em um
          único arquivo, para economizar chamadas de procedimento, ao invés do server chamar vários arquivos 
          js, ele chama um único que contém todas as funções necessárias.
        </p>
        <h5 class="mt-3"> Técnicas de otimização </h5>
        <h6> Minification</h6>
        <p class="mt-3">Consiste em tirar os espaços em brancos, normalmente arquivos minificados são
          nomeados da seguinte forma arquivo.min.js  </p>

          <h6> Uglification </h6>
          <p class="mt-3">Consiste em reduzir o nome das classes e métodos a duas letras, por exemplo:
            HomeComponent se transforma em hC, onClick()vira oc().
          </p>

          <h6>Bundling</h6>
          <p class="mt-3">
            É a combinação de múltiplos  arquivos javascript em um só, dessa forma a aplicação executa o download 
            apenas uma vez, ao invés de fazer várias requisições.
          </p>
          <h6 class="mt-3">Eliminação de código morto</h6>
          <p class="mt-3"> Elimina códigos que não são utilizado em parte alguma da aplicação, libraries ou código</p>
          <h6 class="mt-3">Ahead-of-time (AOT) compilation </h6>
          <p class="mt-3">
            Angular compiler transforma código javascript em outro código javascript, e o compilador atua
            Just in Time, a desvantagem dessa abordagem é que para cada usuário o compilador terá 
            que executar a compilação de toda a aplicação, quanto mais componentes, mais lenta fica, é ineficiente
            para produção. Uma outra abordagem é utilizar a o modelo AOT (ahead of time),
            nesse modelo a compilação é feita antes do deploy e não é preciso fazê-la para cada usuário,
            o usuário irá baixar o arquivo final pré-compilado, assim a aplicação iniciará mais rápido,
            os bundles possuem tamanho menor, os erros do template podem ser capturados em tempo de compilação,
            já que nesse modelo a compilação não é em tempo de execução. Este modelo também é mais seguro.
          </p>
          <h5 class="mt-3">Building</h5>
          <p class="mt-3">
            As configurações de build de produção estão dentro do arquivo angular.json, dentro da chave "build" -> "configuration" 
            onde há pelo menos três configurações, production, development e test. a pasta dist, na raiz da aplicação
            corresponde a aplicação compilada com os arquivos necessários para a aplicação funcionar. Esta pasta é a versão
            otimizada, minificada e com os assets necessários para levar a pasta para produção.
          </p>
          <h5 class="mt-3">Ambientes</h5>
          <p class="mt-3">
            usualmente os arquivos de definição de ambiente, "environment", são encontrados na pasta
            app/environments, dentro dessa pasta, por padrão, existem dois arquivos typescript, um para o
            ambiente de produção "environment.prod.ts e outro para desenvolvimento: environment.ts.
            basicamente eles contêm um objeto de mesmo nome com a propertie production setada para true 
            e false, respectivamente, por motivos óbvios.
          </p>
          <h5 class="mt-3">Linter</h5>
          <p class="mt-3">
            É um tipo de programa que verifica se seu código obedece as melhores práticas de
            programação e organização do código, um linter conhecido é o tslint. 
          </p>
     </div>
   </div>

  

</div>