<div class="container">

  <nav class="navbar navbar-expand-md navbar-light bg-light">
    <div class="container-fluid">
      <a href="#" class="navbar-brand">
        <img src="../assets/AngularJS-Shield.svg" width="50px" height="55px" alt="">
        <strong> Curso de Angular </strong>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarPrincipal"
        aria-expanded="false" aria-label="Toggle navigation" aria-controls="navbarPrincipal">
        <span class="navbar-toggler-icon">
        </span>
      </button>

      <div class="collapse navbar-collapse" id="navbarPrincipal">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Home'"
              [class.active]="menuEscolhido == 'Home'">Home</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Diretivas'"
              [class.active]="menuEscolhido == 'Diretivas'">Diretivas</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Componente'"
              [class.active]="menuEscolhido == 'Componente'">Componentes</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Template'"
              [class.active]="menuEscolhido == 'Template'">Template Driven</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'reactive'"
              [class.active]="menuEscolhido == 'reactive'">Reactive Driven</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'services'"
              [class.active]="menuEscolhido == 'services'">Services</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'routers'"
              [class.active]="menuEscolhido == 'routers'">Rotas</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Outros'"
              [class.active]="menuEscolhido == 'Outros'">Outros</a>
          </li>
        </ul>

      </div>
    </div>
  </nav>

  <div [ngSwitch]="menuEscolhido">

    <div *ngSwitchCase="'Diretivas'">
      <app-submenus [subMenus]="menusDiretivas" (menuAtivado)="updateViewMode($event)"> 
      </app-submenus>    

      <div [ngSwitch]="viewMode">
        <div *ngSwitchCase="'if'" class="m-2">
          <h3> Como adicionar ou remover elementos da página </h3>
          <span class="fs-6 lh-base">
            Para adicionar ou remover um elemento, utilize *NgIf em conjunto com uma expressão ou variável booleana.
            Por padrão, ngIf evita que seja exibido um elemento com um valor nulo associado. Há diversas formas de
            adicionar ou
            remover elementos, no exemplo abaixo, a div aparecerá se a condição do if retornar verdadeiro, caso retorne
            falso, o elemento
            é retirado da tela e também do DOM.
          </span>

          <div class="mt-3 row g-2 bg-light p-2">
            
              <div class="col-auto">
                <label for="totalDeCursos" class="align-middle">Total de Cursos</label>
              </div>
              <div class="col-auto">
                <input type="number" #totalCursos class="form-control form-control-md">
              </div>
              <div class="col-auto">
                <button class="btn btn-primary btn-md" (click)="onKeyUp(totalCursos.value)">Enviar</button>
              </div>
              <div class="col-auto">
                <span class="align-middle">Informe um valor e clique em enviar para testar a diretiva ngIf </span>
              </div>
            
          </div>

          <h5 class="m-2"> 1. Utilizando a diretiva *ngIf </h5>
          <span class="fs-6 lh-base">
            Para testar o exemplo informe um valor para Total de Cursos no formulário logo acima, se o valor for maior
            que 0 haverá cursos e a div com a mensagem "Lista de Cursos" aparecerá, caso seja 0 a div exibida será 
            a que possui a mensagem "Ainda não há cursos".
          </span>
          <pre class="bg-light">
                {{ textoHtml }}
              </pre>

          <div *ngIf="courses.length > 0" class="p-3 bg-light text-primary border border-primary">
            Lista de Cursos
          </div>

          <div *ngIf="courses.length == 0" class="p-3 bg-light text-danger border border-danger">
            Ainda não há cursos
          </div>
          <h5 class="m-2"> 2. Utilizando *ngIf com template variable e ng-template </h5>
          <span class="fs-6 lh-base">
            A seguir, têm-se o mesmo resultado do if anterior, utilizando ng-template e a instrução else,
            repare que a template variable #noCourses e #coursesList foram utilizadas para chamar o ng-template
            correspondente. a template variable é a referência para a div que será exibida conforme resultado
            do if.
          </span>

          <pre class="bg-light">
                {{ textoHtmlIfNGTemplate }}
          </pre>

          <div *ngIf="courses.length > 0; then coursesList else noCourses"> </div>
          <ng-template #coursesList class="border border-primary text-primary">
            <div class="border border-primary text-primary-3 p-3"> Lista de Cursos </div>             
          </ng-template>

          <ng-template #noCourses>
            <div class="border border-danger text-danger p-3"> Ainda não há cursos </div> 
          </ng-template>
          
          <h5 class="m-2">3. Utilizando hidden para adicionar ou remover elementos </h5>

          <span class="lh-base fs-6">
            O atributo hidden é uma alternativa para ocultar e mostrar elementos, pode ser utilizado como uma property
            bind em conjunto com uma expressão booleana, o resultado da expressão define se o elemento aparece ou não,
            a principal diferenção para o ngIf é que, neste caso, ambas as divs aparecem no DOM, ou seja, se inspecionarmos
            o HTML verificaremos que as duas divs estão no código fonte, embora não apareçam na tela.
          </span>         
          <pre class="bg-light">
            {{textoHtmlHidden}}
          </pre>
          <div [hidden]="courses.length == 0" class="text-primary border border-primary p-3">
            Lista de cursos
          </div>
          <div [hidden]="courses.length > 0" class="text-danger border border-danger p-3">
            Ainda não há cursos
          </div>

        </div>

        <div *ngSwitchCase="'switch'"> 
          <h3 class="p-2"> Como utilizar a diretiva ngSwitchCase</h3>
          <div>
          <span class="lh-base fs-6">
            O ngSwitchCase directive é recomendável para quando queremos comparar uma property ou um field 
            contra múltiplos valores, um exemplo prático de uso seria a ativação de menus quando clicados. 
            Conforme exemplificado abaixo, neste cenário, tem-se uma lista de opções, quando a opção for clicada
            o evento (click) atribui um valor para a property testeSwitch, esse valor atribuído é utilizado 
            para verificar se a classe 'active' utilizada para destacar a opção clicada será ou não habilitada,
            para que ela seja habilitada é necessário que a expressão "testeSwitch == 'valor'" seja verdadeira. Em sendo 
            verdadeira além da ativação da classe active, a div correspondente será exibida, conforme instrução
            ngSwitchCase.
          </span>
          
          
        </div>
          <pre class="bg-light">
            {{ textoSwitchCase }}
          </pre>
       
          <ul class="nav nav-tabs">
            <li class="nav-item"> 
              <a href="#" class="nav-link" [class.active]="testeSwitch == 'mapa'" (click)="testeSwitch = 'mapa'">Mapa</a>  
            </li>
            <li class="nav-item"> 
              <a href="#" class="nav-link" [class.active]="testeSwitch == 'lista'" (click)="testeSwitch = 'lista'">Lista</a> 
            </li>
            <li class="nav-item"> 
              <a href="#" class="nav-link" [class.active]="testeSwitch == 'outros'" (click)="testeSwitch = 'outros'">Outros</a> 
            </li>
          </ul>

          <div [ngSwitch]="testeSwitch">
            <div *ngSwitchCase="'mapa'" class="p-2"> Conteúdo de Mapa </div>
            <div *ngSwitchCase="'lista'" class="p-2"> Conteúdo de Lista </div>
            <div *ngSwitchCase="'outros'" class="p-2"> Conteúdo de Outros </div>
          </div>
       
        </div>

        <div *ngSwitchCase="'for'">
          <h3 class="p-2">Utilizando o NgFor</h3>
          <span class="fs-6 lh-base">
            Utilizado para renderizar uma lista de objetos o NgFor tem também valores exportáveis,
            são valores que podem ser extraídos com o uso de palavras reservadas, estes valores são:
            first: boolean; index: number; last: boolean; even: boolean; odd: boolean; count int, o significado é
            auto-explicativo. No exemplo abaixo o usuário informa a quantidade de cursos que quer exibir,
            valor entre 1 e 10 e o ngFor faz a exibição do html correspondente. Também é possível incluir os
            índices e marcar se deseja apenas as ocorrências pares ou ímpares.
          </span>
          <div class="row g-2 p-3 bg-light mt-2">
            <div class="col-auto">
              <label class="align-middle" for="totalDeCursos"> Informe a quantidade de cursos<br /> a serem exibidos</label>
            </div>
            <div class="col-auto">
              <input type="number" class="form-control" id="totalDeCursos" #total>
            </div>
            <div class="col-auto">
              <input type="button" class="btn btn-primary" value="Ver Cursos" (click)="onClickSendTotal(total.value)">
            </div>
            <div class="col-auto form-check form-switch m-3">              
              <input type="checkbox" class="form-check-input" id="flexSwitchIndice"  [(ngModel)]="mySwitch" > 
              <label for="flexSwitchIndice" class="form-check-label"> Mostrar índices? </label>
            </div>
            <div class="col-auto form-check form-switch m-3">              
              <input type="checkbox" class="form-check-input" id="flexSwitchIndice" [(ngModel)]="switchPar"> 
              <label for="flexSwitchIndice" class="form-check-label"> Mostrar apenas pares? </label>
            </div>
            <div class="col-auto form-check form-switch m-3">              
              <input type="checkbox" class="form-check-input" id="flexSwitchIndice" [(ngModel)]="switchImpar"> 
              <label for="flexSwitchIndice" class="form-check-label"> Mostrar apenas ímpares? </label>
            </div>
          </div>
          <ul class="list-group list-group-flush">            
            <li class="list-group-item" *ngFor="let curso of cursos; let i = index; let isEven = even; let isOdd = odd; trackBy: trackby">

              <div *ngIf="switchImpar == true; then impares; else null;"> </div>
              <div *ngIf="switchPar == true; then pares; else null;"> </div>
              <div *ngIf="switchPar == false && switchImpar == false; then todos; else null;"> </div>

              <ng-template #impares>
                  <span *ngIf="isEven"> <span [hidden]="mySwitch == false"> {{ i }} - </span> {{ curso.nome }}  </span>
              </ng-template>

              <ng-template #pares>
                <span *ngIf="isOdd"> <span [hidden]="mySwitch == false"> {{ i }} - </span> {{ curso.nome }} </span>
              </ng-template>

              <ng-template #todos>
                <span> <span [hidden]="mySwitch == false"> {{ i }} - </span> {{ curso.nome }}  </span>                 
              </ng-template>              
            </li>
          </ul>


          <pre class="bg-light">
            {{ textoFor }}
          </pre>
          <h4> Uso do trackBy </h4>
          <span class="m-2 fs-6 lh-base">
            A diretiva NgFor possui a variável trackBy que recebe uma função, a função implementa a forma como
            as mudanças nos elementos serão rastreados pelo angular, caso ela não seja implementada o padrão do Angular é utilizar
            a referência do objeto, ou seja, será sempre um valor novo quando a página for atualizada, caso deseje
            que o Angular substitua os itens da lista somente quando forem de fato adicionados novos itens,
            implemente o método trackByFn, este método recebe dois parâmetros: index e item. O uso do trackBy é especialmente
            útil quando temos um grande volume de dados, usando o trackBy diminuímos o uso de recursos, auxiliando
            no desempenho da aplicação.
          </span>

          <pre class="bg-light">
            {{textoTrackBy}}
          </pre>
        </div>
        <div *ngSwitchCase="'ngclasse'" class="m-2">
          <h3> Utilizando o ngClass </h3>
          <span class="fs-6 lh-base">
            Suponha a necessidade da criação de um componente para favoritar um determinado item,
            esse componente deve ficar preenchido quando clicado pela primeira vez (favoritado) e deve
            se esvaziar quando desfavoritado, para implementar essa ação você pode utilizar um duplo 
            class binding, onde sempre que o item for clicado a classe oposta a que está 
            ativada é habilitada, assim:
            
            <pre class="bg-light">
              {{ textoClassBinding }}
            </pre>
          </span>
          <span class="mb-4"> Clique na estrela para visualizar o funcionamento do componente </span>
          <app-favorite [favorito]="post.isFavorite" (change)="onFavoriteChanged($event)"> </app-favorite>
          <br />
          <span class="fs-6">
            Uma abordagem alternativa seria utilizar o ngClass, passando um objeto chave valor onde o nome da
            classe é a chave e a propriedade é o valor, assim:
          </span>
          <pre class="bg-light">
            {{ textoNgClass }}
          </pre>
          <span> O que também pode ser feito com o uso de uma expressão no class binding, passando a 
            expressão como um objeto, bastante similar ao ngClass, assim:
          </span>
          <pre class="bg-light">
            {{textoExpressaoClassBinding}}
          </pre>
    
        </div>
        <div *ngSwitchCase="'ngestilo'">
          <h3 class="m-2"> Utilizando o NgStyle </h3>
          <span class="fs-6 lh-base">
            Similar ao ngClass, o ngStyle permite que seja passado um objeto com as chaves funcionando
            como o nome dos atributos css e os valores podem ser expressões que retornam o valor para 
            o atributo.
          </span>
          <button
            [style.backgrounColor]="canSave ? 'blue': 'red'"
            [style.color]="canSave ? 'blue' : 'black'">             
            Salvar 
          </button>
          
    
        </div>
        <div *ngSwitchCase="'outros'" class="m-2">
          <h4> Leading Asterisk </h4>
          <span class="fs-6 lh-base">
            O asterisco que precede as diretivas *ngIf, *ngFor e outras é utilizado para sinalizar a
            substituição do conteúdo interno do elemento que o contém por um ng-template, na prática ele
            facilita a construção dos blocos ngIf encapsulando a criação dos blocos, sem o seu uso a criação
            de um ngIf teria que prever o if e o else, veja no código abaixo como seria:
          </span>
          <pre class="bg-light">
            {{ textNgIfSemAsterisco }}
          </pre>
          </div>

     
      </div>
      
    </div>
    
    <div *ngSwitchCase="'Componente'">
      <app-submenus [subMenus]="menusComponentes" (menuAtivado)="updateViewMode($event)"></app-submenus>

      <div [ngSwitch]="viewMode">

        <div *ngSwitchCase="'overview'" class="m-2">
          <h3> Visão Geral dos Componentes </h3>
          <span class="fs-6">
            As aplicações Angular são baseadas em componentes, os componentes são os principais blocos de 
            construção do Angular. Cada componente possui:           
          </span>
          <ul class="list-group list-group-flush fs-6">
            <li class="list-group-item"> <small> Um template HTML com a marcação e conteúdo da página </small></li>
            <li class="list-group-item"> <small>  classe TypeScript que define o comportamento do componente </small></li>
            <li class="list-group-item"> <small> Um seletor CSS que define como o componente será invocado </small></li>              
          </ul>
          <span>
              Para criar um componente é requisito ter instalado também o Angular CLI e também ter 
              criado um workspace do Angular com os arquivos iniciais de uma aplicação Angular, para 
              criar digite ng new project-name, onde project-name é o nome de sua aplicação angular.
          </span>

          <h4 class="mt-2">Criando um componente</h4>
          <span>
            A melhor forma de criar um componente é pelo uso do Angular CLI, mas também pode ser feito 
            manualmente, para criar através do  Agular CLI, navegue até a pasta do seu projeto Angular, digite            
             <code class="bg-light">ng generate component component-name </code>, conde component-name 
            é o nome do seu componente. Por padrão, este componente cria o seguinte:
          </span>
          <ul class="list-group list-group-numbered fs-6">
            <li class="list-group-item">Um diretório com o mesmo nome do componente</li>
            <li class="list-group-item">O arquivo do componente component-name.component.ts</li>
            <li class="list-group-item">Um template html, component-name.component.html</li>
            <li class="list-group-item">Um arquivo CSS, component-name.component.css</li>
            <li class="list-group-item">Um arquivo de especificação de testes component-name.component.spec.ts</li>
          </ul>
        </div>

        <div *ngSwitchCase="'viewencapsualtion'" class="m-2">
          
          <h3> View Encapsulation </h3>
          <span>
            No angular, o estilo de um componente pode ser encapsulado para limitar-se ao componente, assim, 
            não afeta o restante da aplicação, dentro do @Component decorator é disponibilizada a opção 
            encapsulation, que pode ser utilizada para controlar como o encapsulamento é aplicado. 
            Existem os seguintes modos:
          </span>
          <table class="table table-striped table-bordered">
           <thead>
            <tr>
              <th>Modo</th>
              <th>Detalhe</th>
            </tr>
          </thead>
        <tbody>
        
            <tr>
              <td> ViewEncapsulation.ShadowDom</td>
              <td> O Angular utilizará o Shadow DOM API built-in do navegador para aplicar os estilos de forma isolada ao componente, contudo, 
                nem todos os navegadores possuem suporte para tal.</td>
            </tr>
            <tr>
              <td> ViewEncapsulation.Emulated</td>
              <td> O Angular modifica os seletores CSS aplicados ao componente, dessa forma ele emula o Shadow DOM. 
                Exemplo: quando definimos no css do nosso componente um  h1  color: red; os elementos h1 
                definidos no html do componente receberão um atributo do tipo ngcontent, e o angular criará 
                uma marcação css diferenciada para todos os h1 que tiverem esse atributo, assim:
                <pre>
                  {{textoEncapsulation}}
                 </pre> 
              </td>
            </tr>
            <tr>
              <td> ViewEncapsulation.None</td>
              <td> O Shadow DOM não é aplicado, assim, os estilos são válidos globalmente.</td>
            </tr>
          </tbody>
          </table>
        </div>

          <div *ngSwitchCase="'sharingdata'" class="m-2">
            <h3> Compartilhamento de Dados </h3>
            <div>
             <h5> Input e Outputs properties  </h5>
              <span>
              Quando trabalhamos com componentes, eventualmente necessitamos utilizar suas propriedades e 
              seus métodos para passar o estado do componente e reagir a eventos disparados, para isso, 
              utilizamos Input e Output properties, a isso dá-se o nome de "public API". Sem as anotações 
              de Input e Output não é possível utilizar property binding e event binding no componente.
            </span> <br />

            <span>
              Os decorators @Input() e @Output() permitem o compartilhamento de dados entre child e parent 
              directives e components, o @Input() permite que o componente pai atualize dados no componente 
              filho, já o @Output() permite que o elemento filho envie dados para o elemento pai.
            </span>
            
            <h4 class="mt-3"> Enviando dados para um elemento filho </h4>
              

              O @Input() decorator em um elemento filho ou diretiva significa que a propriedade pode 
              receber seu valor de um componente pai, ele passa a ser uma entrada de dados.
            <br />
            <code>
              @Input => Parent => Child.
            </code>
            <br>
            Para utilizar o @Input é preciso configurar parent e child elements. o @Input é declarado
            onde se pretende receber o valor <br />
            <code>
            @Input() item = '';
            </code>
            <br />
            item pode ser de qualquer tipo, inclusive um objeto, o valor de item vem do componente pai. 
            No template do componente filho, tem-se:
            <br />
            <code>              
              {{textoInputP}}
            </code>
            <br>
            <span>
              No componente pai, fazemos o property binding propriamente dito, neste caso estamos 
              trabalhando no app-component como sendo o componente pai, pois ele engloba o componente 
              app-item-detail.
            </span>
            <br>
            <code>{{textoInputCP}}</code>
            <br>
            <span>
              Agora basta passar o valor para a input property, esse valor, no nosso exemplo é o currentItem,
              considerando que o child element recebe o valor, quem passa é o parent element, no nosso exemplo, o valor
              virá do AppComponent.
            </span>
            <br>
            <code> {{textoInputValor}}</code>

            
            <h4 class="mt-3"> Enviando dados para o componente pai</h4>
            <span>
              o @Output decorator em um componente filho ou diretiva permite o fluxo de dados do filho para o pai. 
              o componente filho utiliza o @Output decorator para subir um evento para notificar o componente pai 
              da mudança, para subir o evento, um @Output precisa ter o tipo EventEmitter, que é uma classe do 
              @angular/core que utilizamos para emitir eventos customizados. 
              O exemplo a seguir mostra como configurar um @Output() em um componente filho que envia dados de um 
              HTML para uma array no componente pai. Para usar o @Output() é preciso configurar parent e child.
            </span>

            <h5> Configurando o componente filho </h5>
            <span> O componente emissor do evento precisa de uma property com a tag de @Output 
              e precisa de um método que lance o evento. Suponha então que na child class tenha-se o 
              seguinte cenário:
            </span>
            <pre class="bg-light"> {{ textoOutputP }} </pre>

            <h5> Configurando o template do elemento filho</h5>
            <span>
              Ao clicar no botão o método addNewItem() do componente é acionado, ele possui como parâmetro 
              o valor da template variable #newItem, que nada mais é que o valor que o usuário irá 
              informar no campo de texto
            </span>
            <pre class="bg-light">
              {{ textoOutputEF }}
            </pre>
              <h5>Configurando o componente pai</h5>
              <span>
                Neste exemplo, utilizamos o AppComponent, o qual terá uma lista de itens e um método 
                para adicionar mais itens. o método addItem() irá receber o argumento, no exemplo, 
                uma string.
              </span>
              <pre class="bg-light">
                {{textoCodigoAddItem}}
              </pre>

              <h5>Configurando o template do elemento pai</h5>

              <span>
                No template, (app.component.html), linkamos o método do elemento pai (addItem()), com o 
                evento, marcado como @Output no elemento filho (newItemEvent). Essa chamada é feita na 
                tag do elemento filho, assim:

                <pre class="bg-light">
                  {{textoCodigoChamada}}
                </pre>

                
              </span>
              <span>
                O event binding, (newItemEvent)='addItem($event)', liga o evento do elemento filho ao 
                método do elemento pai. o objeto $event contém os dados que o usuário informa no . Para ver 
                o @Output() funcionando, adicione o seguinte no parent's template:
              </span>

              <pre class="bg-light">
                {{textoExibicao}}
              </pre>
            </div>
          </div>
        </div>
    </div>
    
    <div *ngSwitchCase="'Template'">
      <app-submenus [subMenus]="menusTemplates" (menuAtivado)="updateViewMode($event)"></app-submenus>
      <div [ngSwitch]="viewMode">
        <div *ngSwitchCase="'validacao'" class="m-2">
      <h5 class="mt-3"> Template Driven </h5>
      <span>
        O Angular possui uma classe chamada FormControl, para cada campo existente no formulário essa 
        classe é associada a um objeto que consegue verificar o status e valor do campo. Os estados do campo podem ser:
        <ul class="list-group small">
          <li class="list-group-item">touched: campo foi clicado </li>
          <li class="list-group-item">untouched </li>
          <li class="list-group-item">dirty (value foi alterado) </li>
          <li class="list-group-item">pristine (value não foi alterado) </li>
          <li class="list-group-item">valid </li>
          <li class="list-group-item">erros </li>
        </ul> 
      </span>   
      <span class="mt-3">
        Na mesma linha, existe a classe FormGroup, representa um grupo de controles em um form, todo form tem
        pelo menos um objeto FormGroup.
        Há duas formas de criar controles para seu formulário, uma é por meio de diretivas de forma automática
        (template driven) a outra maneira é criar explicitamente através de código (reactive forms) neste caso
        há um maior controle sobre a lógica de validação. Reactive form é mais recomendável para modelos
        complexos.
        Quando utilizamos a diretiva ngModel, estamos dizendo ao Angular para criar
        um FormControl para aquele input field, sempre que o fazemos devemos também preencher o atributo name 
        do input field.
        <br />
        O campo Nome, codificado abaixo, é um FormControl, para ver o seu funcionamento basta exportar
        o ngModel para uma template variable local, no código de exemplo estamos exportando o valor de ngModel 
        para a template variable #firstName. Tecle f12 e veja o resultado do 
        console.log do javascript, ele deverá mostrar o objeto ngModel.
        Observe o atributo required no input field, ele sinaliza que o campo é de preenchimento obrigatório,
        na mesma linha o atributo minlenght estabelece um número mínimo de caracteres, note que são os mesmos
        atributos que o HTML5 utiliza para validação. o Angular utiliza diretivas para casar esses atributos com 
        as funções de validação do framework. Sempre que o valor de um form é alterado o Angular executa 
        a validação e gera ou uma lista de erros com o resultado INVALID para o objeto, ou nulo, que seria
        o equivalente a VALID.
        a div a seguir contém várias divs aninhadas, elas têm a função de aparecer quando a condição do ngIf 
        não for satisfeita, ou seja, quando a template variable firstName passada para o FormControl 
        for inválida.
        Caso queira customizar a formatação do erro de validação, utilize as classes do angular que apontam para 
        o erro, por exemplo, configure a borda vermelha para as classes .form-control.ng-invalid.ng-touched, dessa 
        forma os elementos dentro de um form-control tocados e inválidos terão a borda vermelha.
      </span>
        <pre class="bg-light">{{ textoNgModel }}</pre>
      
      <app-contact-form> </app-contact-form>
      </div>
    
      <div *ngSwitchCase="'ngForm'">
        <span>
          Por padrão a diretiva ngForm é acrescentada "under the hood" em todos os formulários html 
          quando importamos o módulo FormsModule do Angular,
          para termos uma referência da diretiva ngForm podemos utilizar uma template variable, setando 
          dentro da tag form #f="ngForm", observe que é a mesma lógica para exportar o valor de ngModel 
          para uma template variable em um input field.                    
        </span>
        <h4>ngSubmit</h4>
        <span class="mt-3">
          o NgForm tem uma output property chamada ngSubmit, sendo uma output property ela é do tipo
          EventEmitter e portanto é uma forma de enviar dados a um parent item através do evento ngSubmit.
          Para ver o resultado clique no botão enviar e veja o objeto que está sendo enviado através do console
          das ferramentas do desenvolvedor. <br />
          Repare o elemento button, utilizamos um atributte binding, onde o atributo disabled desabilita
          o botão enquando o formulário estiver no estado inválido, o atributo recebe o valor da template 
          variable #f a qual é atribuída o valor do ngForm.
        </span>
        <pre class="bg-light">{{textoNgForm}}</pre>
        <h4>NgModelGroup</h4>
        <span>
          Outra maneira de separar conceitos é utilizando a diretiva ngModelGroup, quando a diretiva é adicionada 
          a uma div os input fields dentro dela passam a ser considerados atributos de um objeto. Imagine que os
          primeiros campos de um formulário são todos referentes a contato, você pode envolvê-los em uma div 
          e nomear o ngModelGroup como contato, criando uma template variable com o valor #contato e passando 
          para a template variabel o valor de ngModelGroup, conforme demonstrado no código abaixo:
        </span>
        <pre class="bg-light">
          {{textoNgModelGroup}}
        </pre>
        <span> ao clicar no checkbox é possível ver o valor da variável ngModel a ele associada, 
          conseguimos isso através da instrução <code> f.value | json </code>
          <br/>
          sendo f o valor do ngForm em formato json, por isso todo os valores são exibidos, incluindo o input field 
          nome e comentário.
        </span>

  
        <app-contact-form></app-contact-form>
        
      </div>
      <div *ngSwitchCase="'ngValue'">
        <span>
          Ao trabalhar com formulários, eventualmente queremos enviar não apenas um id através de um 
          select box, mas sim o objeto como um todo, imagine a seguinte situação, você tem um tipo de contato 
          e gostaria que ao selecionar o o tipo de contato o objeto fosse integralmente enviado, tanto o id como
          o nome do tipo de contato.
          <br />
          o objeto seria algo como:
          <pre class="bg-light">
            {{textoObjetoContact}}
          </pre>

          o select box seria assim:

          <pre class="bg-light">
            {{textoSelectBox}}
          </pre>
          <app-selectbo>

          </app-selectbo>

        </span>
        <span>
          Com essa abordagem somente o property bind de value é acionado, e somente o id do método de contato
          é enviado, mas isso não é o que queremos, queremos o objeto todo, para enviar o objeto todo basta
          substituir [value] por [ngValue] e contacts.id por contacts. Assim:                
          
        </span>
        <pre class="bg-light">
          {{textoNgValue}}
        </pre>

        <app-select-box2>

        </app-select-box2>
        
      </div>
    </div>
    

  </div>
  <div *ngSwitchCase="'reactive'">
    <app-submenus [subMenus]="menusReactive" (menuAtivado)="updateViewMode($event)">

    </app-submenus>
    <div [ngSwitch]="viewMode">
      <div *ngSwitchCase="'visaogeral'">
        <h5 class="mt-3">Funcionamento do Reactive Driven</h5>
        <span>
          Reactive form transfere mais responsabilidades para o desenvolvedor, o controle dos formulários passa
          a ser feito diretamente no componente e as associações destes formControls com os input fields 
          no template são feitas através de diretivas próprias tais como:
          <strong> formControlName </strong> o qual é representado como um atributo, usado
          para linkar ao input field do FormControl.
          O <strong>  formGroupName</strong> usado para linkar os FormGroups do componente com os grupos 
          do template. Por último o <strong> [formGroup]</strong>, representado como uma property bind, 
          a qual vincula o formulário do template com o form object criado no componente. <br />
          
          O formulário de login, abaixo representado, fora criado usando 
          a abordagem reactive driven do angular. Para tanto, criou-se um objeto FormGroup, composto de outros dois 
          objetos FormControl, um para o username e outro para o password. No template, esses objetos são invocados 
          utilizando o atributte binding no form <code> [formGroup]="form" </code> e atribuição de valor 
          nos inputs utilizando o atributo formControlName para username e password.      
        </span>
        <h5 class="mt-3">Validação de Dados no Reactive Driven </h5>
        <span class="mt-3">
          No reactive form os atributos do HTML não são utilizados para validação, para criar validações é preciso 
          fazê-lo dentro do formControl correspondente, um formControl possui alguns parâmetros, todos eles 
          são opcionais, o primeiro trata do estado inicial do form, o segundo é um validator que é do tipo 
          ValidatorFn[] | ValidatorFn[], ou seja é uma função do tipo Validator (classe built-in do Angular) 
          ou uma array de funções Validator. No Código 1 é possível ver o uso de vários validators e como 
          implementá-los.
        </span>
        <h5 class="mt-3"> Simplificando a chamada do formControl </h5>
        <span>
          as propriedades do form control podem ser obtidas por meio do método get, assim: form.get('name').valid, para simplificar
          essa chamada convém criar uma property no componente, conforme código 2:
        </span>
        <app-coder [parametros]="t"> </app-coder>
        <app-coder [parametros]="codigoSimplificado"> </app-coder>        
        <app-signup-form></app-signup-form>
        
        
      </div>
      <div *ngSwitchCase="'validacaoCustomizada'">
        <h5 class="mt-3">Criando uma validação customizada no Reactive Driven</h5>
        <span>
          Para criar uma validação customizada é preciso criar uma ValidatorFn e passá-la ao seu formControl
          o validatorFn é uma interface e portanto possui um padrão para sua implementação. Para implementar 
          é preciso um AbstractControl que retorne um ValidatorError ou nulo.
        </span>
        <app-coder [parametros]="pp" > </app-coder>
        <h5 class="mt-3">Implementando no template </h5>
        <span>
          O uso no template é exatamente igual ao que seria feito com um validador comum, no componente o 
          validator é chamado através de uma chamada ao método estático criado no username.validator, assim:
        </span>
        <app-coder [parametros]="validadorSignUp"> </app-coder>
       
      </div>
      <div *ngSwitchCase="'validacaoAssincrona'">
        <h5 class="mt-3">Validação Assíncrona </h5>
        <span>
          Para realizar uma validação assíncrona é preciso implementar a interface AsyncValidatorFn,
          essa interface possui a seguinte assinatura:
        </span>
        <app-coder [parametros]="asyncValidatorFn"> </app-coder>
        <span>
          Repare que a interface recebe um AbstractControl como parâmetro e retorna uma promisse de validationErrors ou nulo OU
          um Observable de ValidationErrors ou null. Isso significa que quando a operação for concluída 
          receberemos como retorno uma promise de ValidationErrors ou um Observable de ValidationErrors ou nulo <br />

          também convém compreender como funciona o conceito de operação assíncrona, conceito explicitado 
          neste link (criar link). No nosso exemplo criaremos um método para testar se um valor informado 
          no formulário de login é único. 
          <br />
          O código abaixo retorna um resolve ou um reject, o reject em caso de erro, o resolve se a operação 
          for bem sucedida. O resolve retorna um ValidatorError ou nulo, shouldBeUnique é um ValidatorError, 
          lembrando que o que define um validatorErrorFn é um AbstractControl como parâmetro e o retorno 
          de um outro ValidatorError ou nulo.
        </span>
        <app-coder [parametros]="exemploAsyncValidatorFn"></app-coder>
        <span class="mt-3"> Repare que há um delay entre a digitação do valor no campo e a resposta do 
          navegador, para deixar claro que o sistema está trabalhando, convém uma mensagem ao usuário de 
        loading, isso pode ser obtido através da propriedade <strong>pending </strong> do FormControl, essa 
      propriedade fica ativa enquanto a operação assíncrona está funcionando, para adicioná-la basta 
     utilizar um NgIf para que enquanto pending for verdadeiro apareça uma mensagem do tipo 
    "Checando por valor único" ou uma imagem de loading </span>
      </div>
      <div *ngSwitchCase="'validacaoForm'">
        <span class="mt-3">
          Caso deseje checar um erro que pode ser originado de qualquer parte do formulário, ou seja,
          pode vir de mais de um campo, é possível fazer uma validação no formulário. Suponha que deseje 
          testar se o usuário e senha do componente de login retornaram o valor correto, o form validation 
          pode ser utilizado para isso. 
          <br />
          Abaixo, uma função que gera um erro para o formulário ao tentar logar.

        </span>
        <app-coder [parametros]="erroUsuarioSenha"></app-coder>
        <span class="mt-3">
          Para mostrar o erro, utilizamos o ngIf dentro de uma Div se o form tiver quaisquer erros,
          eles serão mostrados. Caso precise testar vários erros, convém criar uma div, dentro da div principal 
          para cada erro adicional.

        </span>
        
        <app-coder [parametros]="erroUsuarioSenhaTemplate"></app-coder>
        <h5 class="mt-3">Aninhamento de grupos no Reactive Driven</h5>
        <span>
          Para aninhar grupos na abordagem reactive driven, utilize a diretiva FormGroupName dentro do template 
          dessa forma, o Angular entenderá que há formGroups aninhados no componente, por exemplo. Se você possui 
          no seu componente um código assim:
        </span>
        <app-coder [parametros]="codigoFormGroupAninhado"></app-coder>
        <span class="mt-3">
          deverá implementar o seu template assim:
        </span>
        <app-coder [parametros]="codigoFormGroupTemplate"> </app-coder>
        <span>

        </span>

        
      </div>
      <div *ngSwitchCase="'FormArray'">
        <h5 class="mt-3">Trabalhando com um FormArray </h5>
        <span>
          O FormArray é mais uma classe que assina a interface AbstractControl, mesma família do FormGroup. Para 
          utilizar um FormArray você pode criar um objeto do tipo FormGroup e colocar um FormArray dentro dele,
          como no código de exemplo abaixo:
        </span>

        <br/>
        <app-coder [parametros]="codigoFormArray"></app-coder>
        <p class="mt-3">
          Imagine que você precise criar uma lista de itens de supermercado, a medida que o usuário preencha
          um campo de texto eles devem ser armazenados em uma lista e exibidos na tela, outra funcionalidade 
          importante é que os itens sejam removidos quando clicados. Para fazer isso, 
          basta criar um método de adição de itens, cada item será parte do FormArray, a implementação 
          deste método seria assim:
        </p>
        <app-coder [parametros]="codigoAddTopicoFormArray"></app-coder>
        <p class="mt-3">
          Perceba que a função addTopic recebe como parâmetro um input text field do html, perceba também que uma property 
          de nome topics foi criada para facilitar a referência ao FormArray, sempre que o addTopic for chamado 
          será inserido no FormArray um novo FormControl com o valor informado no FrontEnd, o código 
          do FrontEnd fica assim:
        </p>

        <app-coder [parametros]="codigoFrontEndFormArray"></app-coder>

        <p class="mt-3">
          Teste o Componente abaixo: digite um texto qualquer e tecler enter para chamar o método addTopic, para 
          remover, basta clicar sobre o item da lista que o método removeTopic será chamado.
        </p>
        <app-gerador-objetos></app-gerador-objetos>
      </div>
      <div *ngSwitchCase="'FormBuilder'">
        Antes de falarmos do FormBuilder é importante compreender o que é um Builder dentro do paradigma
        de programação orientado a objetos, um builder é um padrão de criação de objetos, geralmente utilizado 
        em estruturas mais complexas onde um objeto é fruto de uma composição de outros objetos.
        Veja um exemplo da instanciação de um FormGroup padrão (código 1) e em seguida o mesmo resultado 
        utilizando o FormBuilder.
        <app-coder [parametros]="codigoFormBuilder"></app-coder>

        <p class="mt-3">
          Veja que o padrão builder separa a representação do objeto da sua lógica de construção,
          ele precisa de um construtor para criar o builder, esse builder possui métodos parar criar objetos da família 
          de formulários. Veja também que o código que o FormBuilder gera é menor do que a construção 
          do FormGroup.
        </p>
      </div>
    </div>

    
   
    
  </div>

  <div *ngSwitchCase="'services'">
    <app-submenus [subMenus]="menuServices" (menuAtivado)="updateViewMode($event)"> </app-submenus>
    <div [ngSwitch]="viewMode">
      <div *ngSwitchCase="'servicos'">
        <h5 class="mt-3">Separação de Conceitos </h5>
        <p class="mt-3">
          Paradigma em que se baseia o conceito de serviços, estatui que uma classe deve ser responsável
          por apenas um tipo de coisa, uma classe que faz muitas coisas é difícil de manter e testar. 
          Por exemplo, apresentação da lógica de visão e recuperação de dados não devem estar na mesma classe,
          isso aumenta acoplamento e reduz coesão pois as rotinas de recuperação de dados, possivelmente serão repetidas
          em várias classes. Para solucionar essa questão, precisamos separar os conceitos de lógica de apresentação 
          e tratamento de dados, para isso vamos criar um serviço de acesso a dados para o componente. Ou seja,
          o serviço será a camada intermediária entre o componente e o backend.
        </p>
        <h5 class="mt-3">
          Exemplo de separação de conceitos
        </h5>
        <p class="mt-3">
          Veja no código abaixo que a classe PostService se encarrega de acessar e manipular os dados,
          a maneira como ela faz isso está encapsulada na classe de serviço, esses detalhes não devem 
          ser de responsabilidade do componente, o qual deve se preocupar tão somente com a apresentação.
          Neste modelo o componente utiliza injeção de dependência para criar uma instância dos serviços que 
          precisa em seu construtor, como os métodos do HttpClient retornam Observables, para poder 
          ter acesso aos dados na camada de lógica de apresentação os métodos da classe subscrevem o retorno 
          dos services methods e manipulam os dados (map, reduce) conforme conveniência.
        </p>
        <app-coder [parametros]="postService"></app-coder>
        <app-coder [parametros]="postComponent"></app-coder>
      </div>
      <div *ngSwitchCase="'get'">
       
        <h5 class="mt-3">Método get do HttpClient</h5>
          Para simular o backend das aplicações será utilizado o serviço jsonplaceholder, encontrado no endereço 
          jsonplaceholder.typicode.com, este site provê uma série de endpoints com dados para testes.
          Para buscar dados via chamadas remotas você pode utilizar o HttpModule, é um módulo que contém a classe 
          HttpClient, essa classe possui o método get, o qual faz requisições http,
          essa classe é injetada como um serviço e pode ser usada no padrão de injeção de dependência, ou seja,
          por meio de inserção de uma variável tipada no construtor do componente onde deverá ser utilizada.
          <br />
          A chamada do método get pode ser feita conforme código abaixo:
          <app-coder [parametros]="codigoHttpClientGet"></app-coder>
          <span class="mt-3">
            Observe que há uma chamada encadeada na chamada do método, após o get o método subscribe() é chamado,
            isso se deve a necessidade que o método get tem de retornar um Observable, um Observable representa uma 
            sequência de valores ou eventos que ocorrem ao longo do tempo, é desenhada para lidar com fluxos de 
            dados assíncronos e reativos, permitindo que você subscreva para receber atualizações a partir dos 
            fluxos e execute ações quando as atualizações ocorrerem.
            <br />
            Um Observable precisa de um response, o response é passado do método get para o subscribe, o subscribe 
            pode receber os dados e manipulá-los. Veja no exemplo que os dados recebidos do get são atribuídos
            a variável this.posts.
            Em outras palavras, o método subscribe()  define como obter ou gerar valores ou mensagens para serem
            publicadas. 
          </span>
          <app-post></app-post>

          <h5 class="mt-3">Método post do HttpClient</h5>

      </div>
      <div *ngSwitchCase="'post'">
        <p class="mt-3">
          O método post do HTTPClient possui 15 overloads e portanto várias implementações,
          usualmente leva 3 parâmetros, a url, o body e as options http (opcionais). Como todo método httpclient 
          ele retorna um Observable de alguma coisa, pode ser um ArrayBuffer, um blob, uma string um
          evento, etc..
        </p>
        <app-coder [parametros]="codigoHttpClientPost"></app-coder>
        <p class="mt-3">
          O createPost recebe um input text field como parâmetro, faz uma chamada http post, esse método 
          passa a url onde se deseja postar e como segundo argumento passa o valor postado no input. 
          por último subscreve as alterações para ser notificado a medida que elas ocorrerem, a subscrição 
          adiciona o valor postado no server a lista de posts, usa a função splice para adicionar no 
          início da lista e não no final, como seria se fosse utilizado o push. <br />
          Teste o código inserindo um dado qualquer.
        </p>
        <app-post></app-post>
      </div>

      <div *ngSwitchCase="'patch'">
        <p class="mt-3">
          O http patch atualiza apenas os campos que foram alterados, de maneira que ele não envia o 
          objeto inteiro para o server, como faz o put. Abaixo um exemplo:
        </p>

        <app-coder [parametros]="codigoHttpClientPatch"> </app-coder>
      </div>
      <div *ngSwitchCase="'delete'">
        <p class="mt-3">
          O http delete cria um observable que quando subscrito exclui um registro do servidor. 
          não possui um body, apenas uma url e opções http. Sua implementação ficaria assim:
        </p>
        <app-coder [parametros]="codigoHttpClientDelete"></app-coder>
        <p class="mt-3">
          Observe que a implementação do método é bem simples, basta passar a url indicando o 
          item que deseja excluir, na subscrição do método você passa o que deseja fazer com o objeto 
          manipulado, no exemplo, foi excluído do template o elemento correspondente.
        </p>
      </div>
      <div *ngSwitchCase="'dataservice'">
        <h5 class="mt-3">Serviço de acesso a dados</h5>
        <p class="mt-3">
          Suponha que deseje criar um serviço de acesso a dados, uma chamada para um método de recuperação 
          de dados, outro que busque por id específico, outro que delete e outro que atualize, repare que
          são operações comuns que se repetem em vários componentes, ou seja, podemos criar métodos genéricos 
          para tratar essa questão, veja no código abaixo um exemplo do que seria uma classe de serviços.
        </p>
        <app-coder [parametros]="codigoDataService"></app-coder>
      </div>
    </div>
   
  </div>
  <div *ngSwitchCase="'routers'">
    <app-submenus [subMenus]="menusRouters" (menuAtivado)="updateViewMode($event)"> </app-submenus>
    <h5 class="mt-3">Visão Geral</h5>
    <p class="mt-3">
      Um Router é um serviço que provê navegação entre views e manipulação de URLs
    </p>
    <h5 class="mt-3">3 passos para configurar a navegação </h5>
    <p class="mt-3">
      1º Configurar as rotas - é o mapeamento de um caminho para um componente;
      2º Adicionar um router outlet, é onde é mostrado o componente correspondente quando uma dada rota 
      se torna ativa;
      3º Adicionar links.
    </p>
    <app-submenus [subMenus]="menusFollowers"> </app-submenus>
    <app-followers> </app-followers>
    
  </div>
  <div *ngSwitchCase="'Outros'">
    <app-submenus [subMenus]="outrosmenus" (menuAtivado)="updateViewMode($event)">    
    </app-submenus>
     <div [ngSwitch]="viewMode">
        <div *ngSwitchCase="'ajax'">
          <h4 class="mt-3"> Compreendendo Operações Assíncronas </h4>
          <span>
            Operação assíncrona é um processo que não bloqueia o fluxo principal de execução do programa 
            enquanto aguarda o resultado. Em vez disso, a operação é executada em segundo plano e o resultado 
            é retornado quando estiver disponível. Isso permite que o programa continue a executar outras 
            tarefas enquanto aguarda o resultado da operação, aumentando a eficiência e evitando o 
            travamento do programa.

            Exemplos comuns de operações assíncronas incluem requisições de rede, leitura de arquivos ou 
            operações de banco de dados. Em aplicações web, por exemplo, uma operação assíncrona pode ser 
            usada para carregar dados da API sem interromper a interação do usuário com a página.
            <br />
            O setTimeOut do js também é uma função assíncrona, uma vez que estabelece um tempo para 
            execução e retorno do callback lançado, nesse intervalo, os demais processos rodam em paralelo
            <br />
            Em Javascript, para trabalhar com operações assíncronas utilizamos Observables ou Promises. 
          </span>
          <h4 class="mt-3">O que é uma Promise</h4>
          <span class="mt-3">
            Uma promise é a representação de um valor que pode estar disponível agora, no futuro, ou nunca.
            <strong> é uma maneira de tratar operações assíncronas de forma mais simples e organizada.</strong>
            Uma promise pode ter três estados: pendente (pending), resolvida (resolved) ou rejeitada (rejected).
            Quando a operação assíncrona é iniciada, a Promise é criada com o estado pendente. Quando a operação 
            assíncrona é concluída com sucesso, a Promise é resolvida com o valor resultante. Se a operação falhar,
            a Promise é rejeitada com um erro. <br/>
            As Promises podem ser usadas para lidar com a resposta de uma operação assíncrona, permitindo que você
            escreva código de forma mais clara e organizada. Em vez de lidar com callbacks aninhados, você pode 
            usar métodos como 'then' e 'catch' para manipular a resposta da Promise de forma linear.

          
          </span>
        </div>
        <div *ngSwitchCase="'observables'">
            <h5 class="mt-3">
              Definindo um Observable
            </h5>
            <span class="mt-3">
              Um Observable é um contrato composto de algumas funcionalidades, ele deve definir um 
              callback para manipular três tipos de notificações:
              <table class="table table-stripped">
                <thead>
                  <tr>
                    <th> Tipo </th>
                    <th> Detalhes </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>next</td>
                    <td>Parâmetro obrigatório, um handler para cada valor entregue. Chamado nenhuma ou mais vezes
                      depois que a execução se inicia.
                    </td>
                    </tr>
                    <tr>
                      <td>error</td>
                    <td>Opcional. Um handler para uma notificação de erro. Um erro para a execução da instância do 
                      Observable
                    </td>
                  </tr>
                  <tr>
                    <td>complete</td>
                    <td> Opcional: Um handler para notificar a execução completa. Valores atrasados podem 
                      continuar a serem entregues ao next handler depois que a execução é completa.
                    </td>
                  </tr>
                  
                </tbody>
              </table>
              <h5 class="mt-3">
                Subscrevendo
              </h5>
              <p class="mt-3">
                Uma instância de um Observable somente publica valores quando é subscrito. A subscrição é feita 
                através do método subscribe() da instância, passando um observer object para receber as 
                notificações.
                Alguns métodos do RxJS podem ser usados para criar observables, são eles:               
                
              </p>
              <table class="table table-stripped table-bordered">
                <thead>
                  <tr>
                    <th>Método RxJS</th>
                    <th>Detalhes</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>of(...items)</td>
                    <td>Retorna uma instância de Observable que entrega os valores fornecidos como argumentos 
                      de forma síncrona
                    </td>
                  </tr>
                  <tr>
                    <td>from(iterable)</td>
                    <td>Converte seus argumentos para uma instância de Observable. Usualmente utilizado para 
                      converter uma array em um Observable.
                    </td>
                  </tr>
                </tbody>
              </table>
              <p class="mt-3">
                Uma função next() pode receber uma string message, event objects, valores numéricos,
                ou estruturas, dependendo do contexto, em geral, os dados publicados por um observable 
                são referenciados como um stream. Qualquer tipo de valor pode ser representado
                com um observable, e os valores são publicados como um stream.
              </p>
         
            </span>
            <h5 class="mt-3">
              Chamando um subscribe
            </h5>
            <p class="mt-3"> Uma maneira de chamar um subscribe é passando um objeto com 3 
              valores nomeados, sendo que os dois último são opcionais, um next, um error e um complete.
              Veja no exemplo abaixo:
            </p>
            <app-coder [parametros]="chamadaSubscribe"></app-coder>
        </div>
        <div *ngSwitchCase="'promise'">
          <p class="mt-3">
            Uma promise é uma promessa de que algo irá ou não irá ocorrer, utilizada na programação 
            assíncrona para respresentar um valor futuro, se difencia do Observable pelo fato de que 
            seu valor é tido por antecipação (Eager Load), enquanto que o Observable é lazy load,
            é preciso subscrever o resultado para obtê-lo. 
            Há muitos operators que só existem nos Observables, não sendo possível utilizá-los com 
            promises, por isso é preferível utilizar os Observables.
          </p>

        </div>
        <div *ngSwitchCase="'lifecycle'">
          <h5 class="mt-3">Conceitos Gerais</h5>
          <p class="mt-3">
            Uma instância de componente tem um ciclo de vida, que inicia quando o Angular cria a 
            instância do componente e renderiza o componente junto com seus childs items. O ciclo de vida 
            continua com a detecção de alterações, a medida que o Angular verifica por alterações nos dados 
            do componente, em ambos, componente e template. O ciclo de vida finaliza quando o Angular 
            destrói a instância do componente e remove o template do DOM. As diretivas tem um ciclo 
            de vida similar, a medida que o Angular cria, atualiza e destrói instâncias no curso da execução.
            A aplicação pode utilizar métodos para manipular o ciclo de vida dos componentes e seus eventos.
          </p>
          <p class="mt-3">
            Um exemplo de um life cycle event seria: Quando o Angular (criar ou renderizar, ou criar e renderizar 
            seus filhos, destruir um componente) faça algo definido. Um destes eventos é o ngOnInit() o qual 
            é criado automaticamente pelo CLI, observe que os componentes padrões levam a interface OnInit(),
            a criação do componente por padrão implementa a interface OnInit() a qual possui a função 
            ngOnInit(): void. Este método será invocado quando o componente for inicializado, ou seja, está 
            associado ao life cycle hook de inicialização do componente.
          </p>

          <h5 class="mt-3">Os hook methods podem ser descritos conforme tabela abaixo </h5>
          <table class="table table-stripped table-bordered">
            <thead>
              <tr>
                <th>Hook Method</th>
                <th>Propósito</th>
                <th>Timing</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>ngOnChanges()</td>
                <td>Acionado quando o Angular seta ou reseta data-bound input properties. O método recebe 
                  um objeto SimpleChanges dos valores atuais e anteriores de uma property. (Observação:
                  Isso acontece frequentemente, logo, qualquer operação aqui impacta significativamente a performance)
                </td>
                <td>
                  Chamado antes do ngOnInit() (se o componente tiver bound-inputs) e sempre que um ou mais data-bound 
                  input properties sejam alteradas. (Observação: Se o seu componente não possui inputs ou uso do componente
                  sem acionamento dos inputs, o framework não invocará o ngOnChanges().
                </td>
              </tr>
              <tr>
                <td>ngOnInit()</td>
                <td> Inicializa a diretiva ou componente depois do primeiro display dos data-bound properties 
                  e atribuições das diretivas ou properties dos componentes.
                </td>
                <td>Chamado uma vez, depois do primeiro ngOnChanges(). é chamado inclusive quando o ngOnChanges() não é,
                  caso onde não há template-bound inputs. </td>
              </tr>
              <tr>
                <td>ngDoCheck()</td>
                <td>Detecta e atua sob mudanças que o Angular não pode ou não vai detectar por si só.</td>
                <td>Chamado imediatamente depois do ngOnChanges() em cada change detection, e imediamente depois 
                  do ngOnInit() durante a execução inicial do componente.
                </td>
              </tr>
              <tr>
                <td>ngAfterContentInit()</td>
                <td> Atual quando o Angular projeta conteúdo externo dentro dos component views, ou dentro da view 
                  em que a diretiva está.
                </td>
                <td>Chamado uma única vez, depois do primeiro ngDoCheck()</td>
              </tr>
              <tr>
                <td>ngAfterContentChecked()</td>
                <td> Atua quando o Angular checa o conteúdo projetado dentro da diretiva ou componente.</td>
                <td>Chamado depois do ngAfterContentInit() e para cada ngDoCheck()</td>
              </tr>
              <tr>
                <td>ngAfterViewInit()	</td>
                <td> Atua depois que o Angular inicializa os component views e chidls views, ou as views 
                  que contém a diretiva
                </td>
                <td>Chamado uma vez, depois do ngAfterContentChecked()</td>
              </tr>
              <tr>
                <td>ngAfterViewChecked()</td>
                <td>Atua depois do Angular checar as comoponent views e child views, ou as views que contém as diretivas</td>
                <td>Chamado depois do ngAfterViewInit() e em cada ngAfterContentChecked()</td>
              </tr>
              <tr>
                <td>ngOnDestroy()	</td>
                <td>Limpa tudo antes do Angular destruir a diretiva ou o componente. Unsubscribe Observables e 
                  event handlers associados para evitar memory leaks.
                </td>
                <td>Chamado imediamente antes do Angular destruir a diretiva ou componente</td>
              </tr>
            </tbody>
          </table>

          <h5 class="mt-3">Uso do ngOnInit()</h5>
          <p class="mt-3">
            Um exemplo clássico do uso de ngOnInit() é para fazer uma chamada remota de valores a serem 
            exibidos na página, é comum o uso de chamadas https em sistemas de informação. Fazer essa chamada 
            no construtor da aplicação não é aconselhável pois a criação do componente pelo construtor 
            deve ser segura, consumir poucos recursos e ser simples. O método ngOnInit() pode ser utilizado 
            para isso. Não é recomendável que construtores sejam complexos, eles devem se ater a iniciar variáveis 
            locais para valores simples.
          </p>
        </div>
       
        <div *ngSwitchCase="'erros'">
          <h5 class="mt-3">Tipos de Erros</h5>
          <p class="mt-3">
            Há pelo menos dois tipos de erros, os experados e os inesperados. sobre os erros inesperados 
            podemos ainda subdividi-los em três tipos: <br />
         
             Servidor está offline; <br/>
             Rede está off; (Server está on, mas o cliente não consegue alcançar, erro no endereço informado, por exemplo) <br/>
             Exceções não tratadas. (Pode ser por conta de um bug) <br />
          
          </p>
          <p class="mt-3"> Há pelos menos dois tipos gerais de erros esperados: <br />
          Not Found errors (404); <br />
          Bad Request errors (400) <br />
          </p>
          <h5 class="mt-3">Exemplos práticos</h5>
          <p class="mt-3">
            Um observable pode ser utilizado para retornar do servidor os erros de validação de um determinado 
            formulário, esses erros podem ser subscritos e manipulados na property error do subscribe, veja o exemplo 
            abaixo:
          </p>
          <app-coder [parametros]="subscribeComErros"></app-coder>
          <p class="mt-3">
            Observe que a segunda property do observable passado ao subscribe leva um parâmetro do tipo 
            Response, esse parâmetro guarda uma array de erros e várias propriedades como o status do erro,
            podendo ser um erro esperado, como o erro 400, para erros inesperados utilizamos o else.
            Está comentado no código o this.form.setErrors(e), esse código passaria para um objeto form 
            os erros retornados do servidor.
          </p>
          <h5 class="mt-3"> Separando as responsabilidades </h5>
          <p class="mt-3">
            O tratamento de erros deveria ser separado do componente, poderia estar na camada de serviços.
            Para separar os conceitos vamos criar classes para o tratamento dos erros esperados,
            NotFound e BadInput, ambas extendendo AppError. Assim, passamos a tratar os erros da nossa aplicação.
            Na camada de serviços, utilizamos o método pipe para empilhar o mapeamento do response e capturarmos 
            o erro, veja no código abaixo:                     
            
          </p>
          <app-coder [parametros]="codigoPipeCatchError"></app-coder>
          <p class="mt-3">
            No exemplo, foi transferido pro serviço a responsabilidade de lidar com o erro na camada http.
            ele verifica o status do erro e lança o erro para quem chamou o serviço. Na sequência o componente 
            verifica o tipo de erro da aplicação pelo tipo da instância do erro. Veja o código 3:
            
          </p>
          <app-coder [parametros]="codigoErroPostComponent"></app-coder>
          <p class="mt-3">
            o método é subscrito e em caso de erro ele verifica o tipo e exibe uma mensagem para o usuário.
            O tipo do erro é uma implementação que não cabe ao componente e por isso foi delegado a camada 
            de serviço essa verificação. Aqui no componente ele apenas verifica qual a classe do erro para que 
            exiba a mensagem adequada.

          </p>
          <h5 class="mt-3">Criando um ErrorHandler global</h5>
          <p class="mt-3">
            Imagine que você tenha um erro comum a vários componentes, um erro inesperado por exemplo. É um erro que 
            pode ser reutilizado e portanto não precisa repetir a mensagem em todos os componentes. Para 
            criar um manipulador global de um erro, utilize a classe nativa do Angular, ErrorHandler, extenda a classe 
            e implemente o erro. Veja o exemplo no código 4.
          </p>
          <app-coder [parametros]="codigoAppErrorHandler"></app-coder>
          <p class="mt-3">Agora você precisa dizer ao Angular que toda vez que o ErrorHandler for 
            chamado, ou seja, sempre que um erro acontecer, o Angular deve chamar o seu ErrorHandler 
            e não o dele. Para isso é preciso ir no app.module.ts e dizer para substituir o provider 
            ErrorHandler pelo AppErrorHandler, assim:


          </p>
          <app-coder [parametros]="codigoProviderErrorHandler"></app-coder>
          <p class="mt-3">
            Agora sempre que um erro inesperado ocorrer, utilize a instrução throw para lançar para o 
            ErrorHandler. Caso o tipo de erro possível seja apenas um erro inesperado, sequer é preciso 
            chamar o callback de error do subscribe, pois o ErrorHandler é chamado automaticamente.
            Em casos em que há na pilha de erros do callback possíveis erros esperados, é preciso utilizar 
            o callback para poder tratar os erros esperados, como no código abaixo, em que o método delete 
            precisa da chamada do callback de error e o método ngOnInit não, pois só trata de erros 
            inesperados.
          </p>
          <app-coder [parametros]="codigoThrowErrorHandler"></app-coder>
        </div>
     </div>
  </div>
</div>
