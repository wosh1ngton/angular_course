<div class="container">

  <nav class="navbar navbar-expand-md navbar-light bg-light">
    <div class="container-fluid">
      <a href="#" class="navbar-brand">
        <img src="../assets/AngularJS-Shield.svg" width="50px" height="55px" alt="">
        <strong> Curso de Angular </strong>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarPrincipal"
        aria-expanded="false" aria-label="Toggle navigation" aria-controls="navbarPrincipal">
        <span class="navbar-toggler-icon">
        </span>
      </button>

      <div class="collapse navbar-collapse" id="navbarPrincipal">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Home'"
              [class.active]="menuEscolhido == 'Home'">Home</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Diretivas'"
              [class.active]="menuEscolhido == 'Diretivas'">Diretivas</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Componente'"
              [class.active]="menuEscolhido == 'Componente'">Componentes</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Template'"
              [class.active]="menuEscolhido == 'Template'">Template Driven</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'reactive'"
              [class.active]="menuEscolhido == 'reactive'">Reactive Driven</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Injecao'"
              [class.active]="menuEscolhido == 'Injecao'">Injeção de Dependência</a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link" aria-current="page" (click)="menuEscolhido = 'Outros'"
              [class.active]="menuEscolhido == 'Outros'">Outros</a>
          </li>
        </ul>

      </div>
    </div>
  </nav>

  <div [ngSwitch]="menuEscolhido">

    <div *ngSwitchCase="'Diretivas'">
      <app-submenus [subMenus]="menusDiretivas" (menuAtivado)="updateViewMode($event)"> 
      </app-submenus>    

      <div [ngSwitch]="viewMode">
        <div *ngSwitchCase="'if'" class="m-2">
          <h3> Como adicionar ou remover elementos da página </h3>
          <span class="fs-6 lh-base">
            Para adicionar ou remover um elemento, utilize *NgIf em conjunto com uma expressão ou variável booleana.
            Por padrão, ngIf evita que seja exibido um elemento com um valor nulo associado. Há diversas formas de
            adicionar ou
            remover elementos, no exemplo abaixo, a div aparecerá se a condição do if retornar verdadeiro, caso retorne
            falso, o elemento
            é retirado da tela e também do DOM.
          </span>

          <div class="mt-3 row g-2 bg-light p-2">
            
              <div class="col-auto">
                <label for="totalDeCursos" class="align-middle">Total de Cursos</label>
              </div>
              <div class="col-auto">
                <input type="number" #totalCursos class="form-control form-control-md">
              </div>
              <div class="col-auto">
                <button class="btn btn-primary btn-md" (click)="onKeyUp(totalCursos.value)">Enviar</button>
              </div>
              <div class="col-auto">
                <span class="align-middle">Informe um valor e clique em enviar para testar a diretiva ngIf </span>
              </div>
            
          </div>

          <h5 class="m-2"> 1. Utilizando a diretiva *ngIf </h5>
          <span class="fs-6 lh-base">
            Para testar o exemplo informe um valor para Total de Cursos no formulário logo acima, se o valor for maior
            que 0 haverá cursos e a div com a mensagem "Lista de Cursos" aparecerá, caso seja 0 a div exibida será 
            a que possui a mensagem "Ainda não há cursos".
          </span>
          <pre class="bg-light">
                {{ textoHtml }}
              </pre>

          <div *ngIf="courses.length > 0" class="p-3 bg-light text-primary border border-primary">
            Lista de Cursos
          </div>

          <div *ngIf="courses.length == 0" class="p-3 bg-light text-danger border border-danger">
            Ainda não há cursos
          </div>
          <h5 class="m-2"> 2. Utilizando *ngIf com template variable e ng-template </h5>
          <span class="fs-6 lh-base">
            A seguir, têm-se o mesmo resultado do if anterior, utilizando ng-template e a instrução else,
            repare que a template variable #noCourses e #coursesList foram utilizadas para chamar o ng-template
            correspondente. a template variable é a referência para a div que será exibida conforme resultado
            do if.
          </span>

          <pre class="bg-light">
                {{ textoHtmlIfNGTemplate }}
          </pre>

          <div *ngIf="courses.length > 0; then coursesList else noCourses"> </div>
          <ng-template #coursesList class="border border-primary text-primary">
            <div class="border border-primary text-primary-3 p-3"> Lista de Cursos </div>             
          </ng-template>

          <ng-template #noCourses>
            <div class="border border-danger text-danger p-3"> Ainda não há cursos </div> 
          </ng-template>
          
          <h5 class="m-2">3. Utilizando hidden para adicionar ou remover elementos </h5>

          <span class="lh-base fs-6">
            O atributo hidden é uma alternativa para ocultar e mostrar elementos, pode ser utilizado como uma property
            bind em conjunto com uma expressão booleana, o resultado da expressão define se o elemento aparece ou não,
            a principal diferenção para o ngIf é que, neste caso, ambas as divs aparecem no DOM, ou seja, se inspecionarmos
            o HTML verificaremos que as duas divs estão no código fonte, embora não apareçam na tela.
          </span>         
          <pre class="bg-light">
            {{textoHtmlHidden}}
          </pre>
          <div [hidden]="courses.length == 0" class="text-primary border border-primary p-3">
            Lista de cursos
          </div>
          <div [hidden]="courses.length > 0" class="text-danger border border-danger p-3">
            Ainda não há cursos
          </div>

        </div>

        <div *ngSwitchCase="'switch'"> 
          <h3 class="p-2"> Como utilizar a diretiva ngSwitchCase</h3>
          <div>
          <span class="lh-base fs-6">
            O ngSwitchCase directive é recomendável para quando queremos comparar uma property ou um field 
            contra múltiplos valores, um exemplo prático de uso seria a ativação de menus quando clicados. 
            Conforme exemplificado abaixo, neste cenário, tem-se uma lista de opções, quando a opção for clicada
            o evento (click) atribui um valor para a property testeSwitch, esse valor atribuído é utilizado 
            para verificar se a classe 'active' utilizada para destacar a opção clicada será ou não habilitada,
            para que ela seja habilitada é necessário que a expressão "testeSwitch == 'valor'" seja verdadeira. Em sendo 
            verdadeira além da ativação da classe active, a div correspondente será exibida, conforme instrução
            ngSwitchCase.
          </span>
          
          
        </div>
          <pre class="bg-light">
            {{ textoSwitchCase }}
          </pre>
       
          <ul class="nav nav-tabs">
            <li class="nav-item"> 
              <a href="#" class="nav-link" [class.active]="testeSwitch == 'mapa'" (click)="testeSwitch = 'mapa'">Mapa</a>  
            </li>
            <li class="nav-item"> 
              <a href="#" class="nav-link" [class.active]="testeSwitch == 'lista'" (click)="testeSwitch = 'lista'">Lista</a> 
            </li>
            <li class="nav-item"> 
              <a href="#" class="nav-link" [class.active]="testeSwitch == 'outros'" (click)="testeSwitch = 'outros'">Outros</a> 
            </li>
          </ul>

          <div [ngSwitch]="testeSwitch">
            <div *ngSwitchCase="'mapa'" class="p-2"> Conteúdo de Mapa </div>
            <div *ngSwitchCase="'lista'" class="p-2"> Conteúdo de Lista </div>
            <div *ngSwitchCase="'outros'" class="p-2"> Conteúdo de Outros </div>
          </div>
       
        </div>

        <div *ngSwitchCase="'for'">
          <h3 class="p-2">Utilizando o NgFor</h3>
          <span class="fs-6 lh-base">
            Utilizado para renderizar uma lista de objetos o NgFor tem também valores exportáveis,
            são valores que podem ser extraídos com o uso de palavras reservadas, estes valores são:
            first: boolean; index: number; last: boolean; even: boolean; odd: boolean; count int, o significado é
            auto-explicativo. No exemplo abaixo o usuário informa a quantidade de cursos que quer exibir,
            valor entre 1 e 10 e o ngFor faz a exibição do html correspondente. Também é possível incluir os
            índices e marcar se deseja apenas as ocorrências pares ou ímpares.
          </span>
          <div class="row g-2 p-3 bg-light mt-2">
            <div class="col-auto">
              <label class="align-middle" for="totalDeCursos"> Informe a quantidade de cursos<br /> a serem exibidos</label>
            </div>
            <div class="col-auto">
              <input type="number" class="form-control" id="totalDeCursos" #total>
            </div>
            <div class="col-auto">
              <input type="button" class="btn btn-primary" value="Ver Cursos" (click)="onClickSendTotal(total.value)">
            </div>
            <div class="col-auto form-check form-switch m-3">              
              <input type="checkbox" class="form-check-input" id="flexSwitchIndice"  [(ngModel)]="mySwitch" > 
              <label for="flexSwitchIndice" class="form-check-label"> Mostrar índices? </label>
            </div>
            <div class="col-auto form-check form-switch m-3">              
              <input type="checkbox" class="form-check-input" id="flexSwitchIndice" [(ngModel)]="switchPar"> 
              <label for="flexSwitchIndice" class="form-check-label"> Mostrar apenas pares? </label>
            </div>
            <div class="col-auto form-check form-switch m-3">              
              <input type="checkbox" class="form-check-input" id="flexSwitchIndice" [(ngModel)]="switchImpar"> 
              <label for="flexSwitchIndice" class="form-check-label"> Mostrar apenas ímpares? </label>
            </div>
          </div>
          <ul class="list-group list-group-flush">            
            <li class="list-group-item" *ngFor="let curso of cursos; let i = index; let isEven = even; let isOdd = odd; trackBy: trackby">

              <div *ngIf="switchImpar == true; then impares; else null;"> </div>
              <div *ngIf="switchPar == true; then pares; else null;"> </div>
              <div *ngIf="switchPar == false && switchImpar == false; then todos; else null;"> </div>

              <ng-template #impares>
                  <span *ngIf="isEven"> <span [hidden]="mySwitch == false"> {{ i }} - </span> {{ curso.nome }}  </span>
              </ng-template>

              <ng-template #pares>
                <span *ngIf="isOdd"> <span [hidden]="mySwitch == false"> {{ i }} - </span> {{ curso.nome }} </span>
              </ng-template>

              <ng-template #todos>
                <span> <span [hidden]="mySwitch == false"> {{ i }} - </span> {{ curso.nome }}  </span>                 
              </ng-template>              
            </li>
          </ul>


          <pre class="bg-light">
            {{ textoFor }}
          </pre>
          <h4> Uso do trackBy </h4>
          <span class="m-2 fs-6 lh-base">
            A diretiva NgFor possui a variável trackBy que recebe uma função, a função implementa a forma como
            as mudanças nos elementos serão rastreados pelo angular, caso ela não seja implementada o padrão do Angular é utilizar
            a referência do objeto, ou seja, será sempre um valor novo quando a página for atualizada, caso deseje
            que o Angular substitua os itens da lista somente quando forem de fato adicionados novos itens,
            implemente o método trackByFn, este método recebe dois parâmetros: index e item. O uso do trackBy é especialmente
            útil quando temos um grande volume de dados, usando o trackBy diminuímos o uso de recursos, auxiliando
            no desempenho da aplicação.
          </span>

          <pre class="bg-light">
            {{textoTrackBy}}
          </pre>
        </div>
        <div *ngSwitchCase="'ngclasse'" class="m-2">
          <h3> Utilizando o ngClass </h3>
          <span class="fs-6 lh-base">
            Suponha a necessidade da criação de um componente para favoritar um determinado item,
            esse componente deve ficar preenchido quando clicado pela primeira vez (favoritado) e deve
            se esvaziar quando desfavoritado, para implementar essa ação você pode utilizar um duplo 
            class binding, onde sempre que o item for clicado a classe oposta a que está 
            ativada é habilitada, assim:
            
            <pre class="bg-light">
              {{ textoClassBinding }}
            </pre>
          </span>
          <span class="mb-4"> Clique na estrela para visualizar o funcionamento do componente </span>
          <app-favorite [favorito]="post.isFavorite" (change)="onFavoriteChanged($event)"> </app-favorite>
          <br />
          <span class="fs-6">
            Uma abordagem alternativa seria utilizar o ngClass, passando um objeto chave valor onde o nome da
            classe é a chave e a propriedade é o valor, assim:
          </span>
          <pre class="bg-light">
            {{ textoNgClass }}
          </pre>
          <span> O que também pode ser feito com o uso de uma expressão no class binding, passando a 
            expressão como um objeto, bastante similar ao ngClass, assim:
          </span>
          <pre class="bg-light">
            {{textoExpressaoClassBinding}}
          </pre>
    
        </div>
        <div *ngSwitchCase="'ngestilo'">
          <h3 class="m-2"> Utilizando o NgStyle </h3>
          <span class="fs-6 lh-base">
            Similar ao ngClass, o ngStyle permite que seja passado um objeto com as chaves funcionando
            como o nome dos atributos css e os valores podem ser expressões que retornam o valor para 
            o atributo.
          </span>
          <button
            [style.backgrounColor]="canSave ? 'blue': 'red'"
            [style.color]="canSave ? 'blue' : 'black'">             
            Salvar 
          </button>
          
    
        </div>
        <div *ngSwitchCase="'outros'" class="m-2">
          <h4> Leading Asterisk </h4>
          <span class="fs-6 lh-base">
            O asterisco que precede as diretivas *ngIf, *ngFor e outras é utilizado para sinalizar a
            substituição do conteúdo interno do elemento que o contém por um ng-template, na prática ele
            facilita a construção dos blocos ngIf encapsulando a criação dos blocos, sem o seu uso a criação
            de um ngIf teria que prever o if e o else, veja no código abaixo como seria:
          </span>
          <pre class="bg-light">
            {{ textNgIfSemAsterisco }}
          </pre>
          </div>

     
      </div>
      
    </div>
    
    <div *ngSwitchCase="'Componente'">
      <app-submenus [subMenus]="menusComponentes" (menuAtivado)="updateViewMode($event)"></app-submenus>

      <div [ngSwitch]="viewMode">

        <div *ngSwitchCase="'overview'" class="m-2">
          <h3> Visão Geral dos Componentes </h3>
          <span class="fs-6">
            As aplicações Angular são baseadas em componentes, os componentes são os principais blocos de 
            construção do Angular. Cada componente possui:           
          </span>
          <ul class="list-group list-group-flush fs-6">
            <li class="list-group-item"> <small> Um template HTML com a marcação e conteúdo da página </small></li>
            <li class="list-group-item"> <small>  classe TypeScript que define o comportamento do componente </small></li>
            <li class="list-group-item"> <small> Um seletor CSS que define como o componente será invocado </small></li>              
          </ul>
          <span>
              Para criar um componente é requisito ter instalado também o Angular CLI e também ter 
              criado um workspace do Angular com os arquivos iniciais de uma aplicação Angular, para 
              criar digite ng new project-name, onde project-name é o nome de sua aplicação angular.
          </span>

          <h4 class="mt-2">Criando um componente</h4>
          <span>
            A melhor forma de criar um componente é pelo uso do Angular CLI, mas também pode ser feito 
            manualmente, para criar através do  Agular CLI, navegue até a pasta do seu projeto Angular, digite            
             <code class="bg-light">ng generate component component-name </code>, conde component-name 
            é o nome do seu componente. Por padrão, este componente cria o seguinte:
          </span>
          <ul class="list-group list-group-numbered fs-6">
            <li class="list-group-item">Um diretório com o mesmo nome do componente</li>
            <li class="list-group-item">O arquivo do componente component-name.component.ts</li>
            <li class="list-group-item">Um template html, component-name.component.html</li>
            <li class="list-group-item">Um arquivo CSS, component-name.component.css</li>
            <li class="list-group-item">Um arquivo de especificação de testes component-name.component.spec.ts</li>
          </ul>
        </div>

        <div *ngSwitchCase="'viewencapsualtion'" class="m-2">
          
          <h3> View Encapsulation </h3>
          <span>
            No angular, o estilo de um componente pode ser encapsulado para limitar-se ao componente, assim, 
            não afeta o restante da aplicação, dentro do @Component decorator é disponibilizada a opção 
            encapsulation, que pode ser utilizada para controlar como o encapsulamento é aplicado. 
            Existem os seguintes modos:
          </span>
          <table class="table table-striped table-bordered">
           <thead>
            <tr>
              <th>Modo</th>
              <th>Detalhe</th>
            </tr>
          </thead>
        <tbody>
        
            <tr>
              <td> ViewEncapsulation.ShadowDom</td>
              <td> O Angular utilizará o Shadow DOM API built-in do navegador para aplicar os estilos de forma isolada ao componente, contudo, 
                nem todos os navegadores possuem suporte para tal.</td>
            </tr>
            <tr>
              <td> ViewEncapsulation.Emulated</td>
              <td> O Angular modifica os seletores CSS aplicados ao componente, dessa forma ele emula o Shadow DOM. 
                Exemplo: quando definimos no css do nosso componente um  h1  color: red; os elementos h1 
                definidos no html do componente receberão um atributo do tipo ngcontent, e o angular criará 
                uma marcação css diferenciada para todos os h1 que tiverem esse atributo, assim:
                <pre>
                  {{textoEncapsulation}}
                 </pre> 
              </td>
            </tr>
            <tr>
              <td> ViewEncapsulation.None</td>
              <td> O Shadow DOM não é aplicado, assim, os estilos são válidos globalmente.</td>
            </tr>
          </tbody>
          </table>
        </div>

          <div *ngSwitchCase="'sharingdata'" class="m-2">
            <h3> Compartilhamento de Dados </h3>
            <div>
             <h5> Input e Outputs properties  </h5>
              <span>
              Quando trabalhamos com componentes, eventualmente necessitamos utilizar suas propriedades e 
              seus métodos para passar o estado do componente e reagir a eventos disparados, para isso, 
              utilizamos Input e Output properties, a isso dá-se o nome de "public API". Sem as anotações 
              de Input e Output não é possível utilizar property binding e event binding no componente.
            </span> <br />

            <span>
              Os decorators @Input() e @Output() permitem o compartilhamento de dados entre child e parent 
              directives e components, o @Input() permite que o componente pai atualize dados no componente 
              filho, já o @Output() permite que o elemento filho envie dados para o elemento pai.
            </span>
            
            <h4 class="mt-3"> Enviando dados para um elemento filho </h4>
              

              O @Input() decorator em um elemento filho ou diretiva significa que a propriedade pode 
              receber seu valor de um componente pai, ele passa a ser uma entrada de dados.
            <br />
            <code>
              @Input => Parent => Child.
            </code>
            <br>
            Para utilizar o @Input é preciso configurar parent e child elements. o @Input é declarado
            onde se pretende receber o valor <br />
            <code>
            @Input() item = '';
            </code>
            <br />
            item pode ser de qualquer tipo, inclusive um objeto, o valor de item vem do componente pai. 
            No template do componente filho, tem-se:
            <br />
            <code>              
              {{textoInputP}}
            </code>
            <br>
            <span>
              No componente pai, fazemos o property binding propriamente dito, neste caso estamos 
              trabalhando no app-component como sendo o componente pai, pois ele engloba o componente 
              app-item-detail.
            </span>
            <br>
            <code>{{textoInputCP}}</code>
            <br>
            <span>
              Agora basta passar o valor para a input property, esse valor, no nosso exemplo é o currentItem,
              considerando que o child element recebe o valor, quem passa é o parent element, no nosso exemplo, o valor
              virá do AppComponent.
            </span>
            <br>
            <code> {{textoInputValor}}</code>

            
            <h4 class="mt-3"> Enviando dados para o componente pai</h4>
            <span>
              o @Output decorator em um componente filho ou diretiva permite o fluxo de dados do filho para o pai. 
              o componente filho utiliza o @Output decorator para subir um evento para notificar o componente pai 
              da mudança, para subir o evento, um @Output precisa ter o tipo EventEmitter, que é uma classe do 
              @angular/core que utilizamos para emitir eventos customizados. 
              O exemplo a seguir mostra como configurar um @Output() em um componente filho que envia dados de um 
              HTML para uma array no componente pai. Para usar o @Output() é preciso configurar parent e child.
            </span>

            <h5> Configurando o componente filho </h5>
            <span> O componente emissor do evento precisa de uma property com a tag de @Output 
              e precisa de um método que lance o evento. Suponha então que na child class tenha-se o 
              seguinte cenário:
            </span>
            <pre class="bg-light"> {{ textoOutputP }} </pre>

            <h5> Configurando o template do elemento filho</h5>
            <span>
              Ao clicar no botão o método addNewItem() do componente é acionado, ele possui como parâmetro 
              o valor da template variable #newItem, que nada mais é que o valor que o usuário irá 
              informar no campo de texto
            </span>
            <pre class="bg-light">
              {{ textoOutputEF }}
            </pre>
              <h5>Configurando o componente pai</h5>
              <span>
                Neste exemplo, utilizamos o AppComponent, o qual terá uma lista de itens e um método 
                para adicionar mais itens. o método addItem() irá receber o argumento, no exemplo, 
                uma string.
              </span>
              <pre class="bg-light">
                {{textoCodigoAddItem}}
              </pre>

              <h5>Configurando o template do elemento pai</h5>

              <span>
                No template, (app.component.html), linkamos o método do elemento pai (addItem()), com o 
                evento, marcado como @Output no elemento filho (newItemEvent). Essa chamada é feita na 
                tag do elemento filho, assim:

                <pre class="bg-light">
                  {{textoCodigoChamada}}
                </pre>

                
              </span>
              <span>
                O event binding, (newItemEvent)='addItem($event)', liga o evento do elemento filho ao 
                método do elemento pai. o objeto $event contém os dados que o usuário informa no . Para ver 
                o @Output() funcionando, adicione o seguinte no parent's template:
              </span>

              <pre class="bg-light">
                {{textoExibicao}}
              </pre>
            </div>
          </div>
        </div>
    </div>
    
    <div *ngSwitchCase="'Template'">
      <app-submenus [subMenus]="menusTemplates" (menuAtivado)="updateViewMode($event)"></app-submenus>
      <div [ngSwitch]="viewMode">
        <div *ngSwitchCase="'validacao'" class="m-2">
      <h5 class="mt-3"> Template Driven </h5>
      <span>
        O Angular possui uma classe chamada FormControl, para cada campo existente no formulário essa 
        classe é associada a um objeto que consegue verificar o status e valor do campo. Os estados do campo podem ser:
        <ul class="list-group small">
          <li class="list-group-item">touched: campo foi clicado </li>
          <li class="list-group-item">untouched </li>
          <li class="list-group-item">dirty (value foi alterado) </li>
          <li class="list-group-item">pristine (value não foi alterado) </li>
          <li class="list-group-item">valid </li>
          <li class="list-group-item">erros </li>
        </ul> 
      </span>   
      <span class="mt-3">
        Na mesma linha, existe a classe FormGroup, representa um grupo de controles em um form, todo form tem
        pelo menos um objeto FormGroup.
        Há duas formas de criar controles para seu formulário, uma é por meio de diretivas de forma automática
        (template driven) a outra maneira é criar explicitamente através de código (reactive forms) neste caso
        há um maior controle sobre a lógica de validação. Reactive form é mais recomendável para modelos
        complexos.
        Quando utilizamos a diretiva ngModel, estamos dizendo ao Angular para criar
        um FormControl para aquele input field, sempre que o fazemos devemos também preencher o atributo name 
        do input field.
        <br />
        O campo Nome, codificado abaixo, é um FormControl, para ver o seu funcionamento basta exportar
        o ngModel para uma template variable local, no código de exemplo estamos exportando o valor de ngModel 
        para a template variable #firstName. Tecle f12 e veja o resultado do 
        console.log do javascript, ele deverá mostrar o objeto ngModel.
        Observe o atributo required no input field, ele sinaliza que o campo é de preenchimento obrigatório,
        na mesma linha o atributo minlenght estabelece um número mínimo de caracteres, note que são os mesmos
        atributos que o HTML5 utiliza para validação. o Angular utiliza diretivas para casar esses atributos com 
        as funções de validação do framework. Sempre que o valor de um form é alterado o Angular executa 
        a validação e gera ou uma lista de erros com o resultado INVALID para o objeto, ou nulo, que seria
        o equivalente a VALID.
        a div a seguir contém várias divs aninhadas, elas têm a função de aparecer quando a condição do ngIf 
        não for satisfeita, ou seja, quando a template variable firstName passada para o FormControl 
        for inválida.
        Caso queira customizar a formatação do erro de validação, utilize as classes do angular que apontam para 
        o erro, por exemplo, configure a borda vermelha para as classes .form-control.ng-invalid.ng-touched, dessa 
        forma os elementos dentro de um form-control tocados e inválidos terão a borda vermelha.
      </span>
        <pre class="bg-light">{{ textoNgModel }}</pre>
      
      <app-contact-form> </app-contact-form>
      </div>
    
      <div *ngSwitchCase="'ngForm'">
        <span>
          Por padrão a diretiva ngForm é acrescentada "under the hood" em todos os formulários html 
          quando importamos o módulo FormsModule do Angular,
          para termos uma referência da diretiva ngForm podemos utilizar uma template variable, setando 
          dentro da tag form #f="ngForm", observe que é a mesma lógica para exportar o valor de ngModel 
          para uma template variable em um input field.                    
        </span>
        <h4>ngSubmit</h4>
        <span class="mt-3">
          o NgForm tem uma output property chamada ngSubmit, sendo uma output property ela é do tipo
          EventEmitter e portanto é uma forma de enviar dados a um parent item através do evento ngSubmit.
          Para ver o resultado clique no botão enviar e veja o objeto que está sendo enviado através do console
          das ferramentas do desenvolvedor. <br />
          Repare o elemento button, utilizamos um atributte binding, onde o atributo disabled desabilita
          o botão enquando o formulário estiver no estado inválido, o atributo recebe o valor da template 
          variable #f a qual é atribuída o valor do ngForm.
        </span>
        <pre class="bg-light">{{textoNgForm}}</pre>
        <h4>NgModelGroup</h4>
        <span>
          Outra maneira de separar conceitos é utilizando a diretiva ngModelGroup, quando a diretiva é adicionada 
          a uma div os input fields dentro dela passam a ser considerados atributos de um objeto. Imagine que os
          primeiros campos de um formulário são todos referentes a contato, você pode envolvê-los em uma div 
          e nomear o ngModelGroup como contato, criando uma template variable com o valor #contato e passando 
          para a template variabel o valor de ngModelGroup, conforme demonstrado no código abaixo:
        </span>
        <pre class="bg-light">
          {{textoNgModelGroup}}
        </pre>
        <span> ao clicar no checkbox é possível ver o valor da variável ngModel a ele associada, 
          conseguimos isso através da instrução <code> f.value | json </code>
          <br/>
          sendo f o valor do ngForm em formato json, por isso todo os valores são exibidos, incluindo o input field 
          nome e comentário.
        </span>

  
        <app-contact-form></app-contact-form>
        
      </div>
      <div *ngSwitchCase="'ngValue'">
        <span>
          Ao trabalhar com formulários, eventualmente queremos enviar não apenas um id através de um 
          select box, mas sim o objeto como um todo, imagine a seguinte situação, você tem um tipo de contato 
          e gostaria que ao selecionar o o tipo de contato o objeto fosse integralmente enviado, tanto o id como
          o nome do tipo de contato.
          <br />
          o objeto seria algo como:
          <pre class="bg-light">
            {{textoObjetoContact}}
          </pre>

          o select box seria assim:

          <pre class="bg-light">
            {{textoSelectBox}}
          </pre>
          <app-selectbo>

          </app-selectbo>

        </span>
        <span>
          Com essa abordagem somente o property bind de value é acionado, e somente o id do método de contato
          é enviado, mas isso não é o que queremos, queremos o objeto todo, para enviar o objeto todo basta
          substituir [value] por [ngValue] e contacts.id por contacts. Assim:                
          
        </span>
        <pre class="bg-light">
          {{textoNgValue}}
        </pre>

        <app-select-box2>

        </app-select-box2>
        
      </div>
    </div>
    <div *ngSwitchCase="'Outros'">
     
       Outros
    </div>

  </div>
  <div *ngSwitchCase="'reactive'">
    <span>
      Reactive form transfere mais responsabilidades para o desenvolvedor, o controle dos formulários passa
      a ser feito diretamente no componente
    </span>
    <app-signup-form></app-signup-form>
  </div>
</div>
